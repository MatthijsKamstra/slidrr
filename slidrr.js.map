{
"version":3,
"file":"slidrr.js",
"sourceRoot":"file:///",
"sources":["/usr/local/lib/haxe/std/js/_std/EReg.hx","/usr/local/lib/haxe/std/js/_std/HxOverrides.hx","/Volumes/Data HD/Users/matthijs/Documents/workingdir/haxe/slidrr/src/Main.hx","/usr/lib/haxe/lib/markdown/1,0,0/Markdown.hx","/usr/local/lib/haxe/std/js/_std/Reflect.hx","/usr/local/lib/haxe/std/js/_std/Std.hx","/usr/local/lib/haxe/std/StringBuf.hx","/usr/local/lib/haxe/std/StringTools.hx","/usr/local/lib/haxe/std/js/_std/haxe/ds/StringMap.hx","/usr/local/lib/haxe/std/js/Boot.hx","/usr/lib/haxe/lib/markdown/1,0,0/markdown/AST.hx","/usr/lib/haxe/lib/markdown/1,0,0/markdown/BlockParser.hx","/usr/lib/haxe/lib/markdown/1,0,0/markdown/HtmlRenderer.hx","/usr/lib/haxe/lib/markdown/1,0,0/markdown/InlineParser.hx"],
"sourcesContent":["/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class EReg {\n\n\tvar r : HaxeRegExp;\n\n\tpublic function new( r : String, opt : String ) : Void {\n\t\topt = opt.split(\"u\").join(\"\"); // 'u' (utf8) depends on page encoding\n\t\tthis.r = new HaxeRegExp(r, opt);\n\t}\n\n\tpublic function match( s : String ) : Bool {\n\t\tif( r.global ) r.lastIndex = 0;\n\t\tr.m = r.exec(s);\n\t\tr.s = s;\n\t\treturn (r.m != null);\n\t}\n\n\tpublic function matched( n : Int ) : String {\n\t\treturn if( r.m != null && n >= 0 && n < r.m.length ) r.m[n] else throw \"EReg::matched\";\n\t}\n\n\tpublic function matchedLeft() : String {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\treturn r.s.substr(0,r.m.index);\n\t}\n\n\tpublic function matchedRight() : String {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\tvar sz = r.m.index+r.m[0].length;\n\t\treturn r.s.substr(sz,r.s.length-sz);\n\t}\n\n\tpublic function matchedPos() : { pos : Int, len : Int } {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\treturn { pos : r.m.index, len : r.m[0].length };\n\t}\n\n\tpublic function matchSub( s : String, pos : Int, len : Int = -1):Bool {\n\t\treturn if (r.global) {\n\t\t\tr.lastIndex = pos;\n\t\t\tr.m = r.exec(len < 0 ? s : s.substr(0, pos + len));\n\t\t\tvar b = r.m != null;\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t}\n\t\t\tb;\n\t\t} else {\n\t\t\t// TODO: check some ^/$ related corner cases\n\t\t\tvar b = match( len < 0 ? s.substr(pos) : s.substr(pos,len) );\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t\tr.m.index += pos;\n\t\t\t}\n\t\t\tb;\n\t\t}\n\t}\n\n\tpublic function split( s : String ) : Array<String> {\n\t\t// we can't use directly s.split because it's ignoring the 'g' flag\n\t\tvar d = \"#__delim__#\";\n\t\treturn untyped s.replace(r,d).split(d);\n\t}\n\n\tpublic function replace( s : String, by : String ) : String {\n\t\treturn untyped s.replace(r,by);\n\t}\n\n\tpublic function map( s : String, f : EReg -> String ) : String {\n\t\tvar offset = 0;\n\t\tvar buf = new StringBuf();\n\t\tdo {\n\t\t\tif (offset >= s.length)\n\t\t\t\tbreak;\n\t\t\telse if (!matchSub(s, offset)) {\n\t\t\t\tbuf.add(s.substr(offset));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar p = matchedPos();\n\t\t\tbuf.add(s.substr(offset, p.pos - offset));\n\t\t\tbuf.add(f(this));\n\t\t\tif (p.len == 0) {\n\t\t\t\tbuf.add(s.substr(p.pos, 1));\n\t\t\t\toffset = p.pos + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\toffset = p.pos + p.len;\n\t\t} while (r.global);\n\t\tif (!r.global && offset > 0 && offset < s.length)\n\t\t\tbuf.add(s.substr(offset));\n\t\treturn buf.toString();\n\t}\n}\n\n@:native(\"RegExp\")\nprivate extern class HaxeRegExp extends js.RegExp {\n\tvar m:js.RegExp.RegExpMatch;\n\tvar s:String;\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\n\tstatic function dateStr( date :Date ) : String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear()\n\t\t\t+\"-\"+(if( m < 10 ) \"0\"+m else \"\"+m)\n\t\t\t+\"-\"+(if( d < 10 ) \"0\"+d else \"\"+d)\n\t\t\t+\" \"+(if( h < 10 ) \"0\"+h else \"\"+h)\n\t\t\t+\":\"+(if( mi < 10 ) \"0\"+mi else \"\"+mi)\n\t\t\t+\":\"+(if( s < 10 ) \"0\"+s else \"\"+s);\n\t}\n\n\tstatic function strDate( s : String ) : Date {\n\t\tswitch( s.length ) {\n\t\tcase 8: // hh:mm:ss\n\t\t\tvar k = s.split(\":\");\n\t\t\tvar d : Date = untyped __new__(Date);\n\t\t\tuntyped d[\"setTime\"](0);\n\t\t\tuntyped d[\"setUTCHours\"](k[0]);\n\t\t\tuntyped d[\"setUTCMinutes\"](k[1]);\n\t\t\tuntyped d[\"setUTCSeconds\"](k[2]);\n\t\t\treturn d;\n\t\tcase 10: // YYYY-MM-DD\n\t\t\tvar k = s.split(\"-\");\n\t\t\treturn new Date(cast k[0],cast untyped k[1] - 1,cast k[2],0,0,0);\n\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\tvar k = s.split(\" \");\n\t\t\tvar y = k[0].split(\"-\");\n\t\t\tvar t = k[1].split(\":\");\n\t\t\treturn new Date(cast y[0],cast untyped y[1] - 1,cast y[2],cast t[0],cast t[1],cast t[2]);\n\t\tdefault:\n\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\tstatic function cca( s : String, index : Int ) : Null<Int> {\n\t\tvar x = (cast s).charCodeAt(index);\n\t\tif( x != x ) // fast isNaN\n\t\t\treturn untyped undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\tstatic function substr( s : String, pos : Int, ?len : Int ) : String {\n\t\tif( pos != null && pos != 0 && len != null && len < 0 ) return \"\";\n\t\tif( len == null ) len = s.length;\n\t\tif( pos < 0 ){\n\t\t\tpos = s.length + pos;\n\t\t\tif( pos < 0 ) pos = 0;\n\t\t}else if( len < 0 ){\n\t\t\tlen = s.length + len - pos;\n\t\t}\n\n\t\treturn (untyped s).substr(pos, len);\n\t}\n\n\tstatic function indexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0) i = 0;\n\t\t}\n\t\twhile (i < len)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function lastIndexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>( a : Array<T>, obj : T ) {\n\t\tvar i = a.indexOf(obj);\n\t\tif( i == -1 ) return false;\n\t\ta.splice(i,1);\n\t\treturn true;\n\t}\n\n\tstatic function iter<T>( a : Array<T> ) : Iterator<T> untyped {\n\t\treturn {\n\t\t\tcur : 0,\n\t\t\tarr : a,\n\t\t\thasNext : function() {\n\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t},\n\t\t\tnext : function() {\n\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t}\n\t\t};\n\t}\n\n\tstatic function __init__() untyped {\n#if !js_es5\n\t\t__feature__('HxOverrides.indexOf', if( Array.prototype.indexOf ) __js__(\"HxOverrides\").indexOf = function(a,o,i) return Array.prototype.indexOf.call(a, o, i));\n\t\t__feature__('HxOverrides.lastIndexOf', if( Array.prototype.lastIndexOf ) __js__(\"HxOverrides\").lastIndexOf = function(a,o,i) return Array.prototype.lastIndexOf.call(a, o, i));\n#end\n\t}\n\n}\n","package;\n\nimport jQuery.*;\nimport js.Browser;\nimport js.html.*;\nimport js.html.XMLHttpRequest;\n\nclass Main {\n\t\n\t\n\tprivate var _doc = js.Browser.document;\n\tprivate var _win = js.Browser.window;\n\t\n\tprivate var _width : Int;\n\tprivate var _height : Int;\n\tprivate var _total : Int;\n\tprivate var _currentId : Int = 0;\n\tprivate var _prevId : Int = 0;\n\t\n\tpublic function new () {\n\t\t_doc.addEventListener(\"DOMContentLoaded\", function(event) {\n    \t\treadTextFile('slidrr.md');\n\t\t});\n\t}\n\t\n\tprivate function build(md:String) : Void\n\t{\n\t\tvar slides : Array<String> = md.split('---');\n\t\t_total = slides.length;\n\t\tfor ( i in 0 ... _total ) {\n\t\t\t// trace(slides[i]);\n\t\t\tvar slideHTML = Markdown.markdownToHtml(slides[i]);\n\t\t\tvar div = _doc.createDivElement();\n\t\t\tdiv.id = \"slide_\" + i;\n\t\t\tdiv.className = ('slidrr hidden');\n\t\t\tdiv.innerHTML = slideHTML;\n\t\t\t_doc.body.appendChild(div);\n\t\t}\n\t\t\n\t\tslideId(0,true);\n\t\t\n\t\t_win.onkeydown = function (e){\n\t\t\tonKeyHandler(e);\n\t\t}\n\t\t\t\t\n\t\t// onResizeHandler ();\n\t\t// _win.onresize = function (){\n\t\t// \tonResizeHandler();\n\t\t// }\n\t\t\n\t\tbuildProgress();\n\t\tbuildControle();\n\t\tbuildHelp();\n\t}\n\t\n\t\n\tpublic function buildProgress () : Void\n\t{\n\t\tvar _container = _doc.createDivElement();\n\t\t_container.className = \"progress\";\n\t\t\n\t\tvar _progressbar = _doc.createDivElement();\n\t\t_progressbar.className = \"progress-bar\";\n\t\t\n\t\t_container.appendChild(_progressbar);\n\t\t_doc.body.appendChild(_container);\n\t}\n\n\tpublic function buildControle () : Void\n\t{\n\t\tvar _container = _doc.createDivElement();\n\t\t_container.className = \"controls\";\n\t\t\n\t\tvar _arrowL = _doc.createDivElement();\n\t\t_arrowL.className = \"arrow left prev\";\n\t\t_arrowL.innerHTML = \"\";\n\t\tvar _arrowR = _doc.createDivElement();\n\t\t_arrowR.className = \"arrow right next\";\n\t\t_arrowR.innerHTML = \"\";\n\t\t\n\t\t_container.appendChild(_arrowL);\n\t\t_container.appendChild(_arrowR);\n\t\t_doc.body.appendChild(_container);\n\t\t\n\t\t_arrowL.onclick = _arrowR.onclick = function (e){\n\t\t\tonClickHandler(e);\n\t\t};\n\t}\n\t\n\tpublic function buildHelp () : Void\n\t{\n\t\tvar _container = _doc.createDivElement();\n\t\t_container.className = \"help\";\n\t\t\n\t\tvar _logo = _doc.createDivElement();\n\t\t_logo.className = \"logo\";\n\t\t\n\t\t_container.appendChild(_logo);\n\t\t_doc.body.appendChild(_container);\n\t}\n\n\t// ____________________________________ move! ____________________________________\n\t\n\tfunction slideId (id:Int, isVisible:Bool) : Void \n\t{\n\t\tvar slide = _doc.getElementById(\"slide_\" + id);\n\t\tslide.className = (isVisible) ? \"slidrr\" : \"slidrr hidden\";\n\t}\n\t\n\tfunction move (dir:Int) : Void \n\t{\n\t\tslideId(_prevId,false);\n\t\t\n\t\tif(dir == -1)\t\t\t\n\t\t\t_currentId--;\n\t\telse \n\t\t\t_currentId++;\n\n\t\tif(_currentId >= (_total-1)) _currentId = (_total-1);\n\t\tif(_currentId <= 0) _currentId = 0;\n\n\t\tslideId(_currentId,true);\n\t\t_prevId = _currentId;\n\t\t\n\t\t// progress\n\t\tvar percentage = (_currentId/(_total-1))*100;\n\t\tvar progress =_doc.getElementsByClassName(\"progress-bar\")[0];\t\t\n\t\tprogress.style.width = Std.string(percentage) + '%';\t\t\n\t}\n\n\t// ____________________________________ handlers ____________________________________\n\n\tfunction onKeyHandler(e:KeyboardEvent) : Void \n\t{\n\t\tswitch (e.keyCode) {\n\t\t\tcase 37 : move(-1);\n\t\t\tcase 39 : move(1);\n\t\t}\n\t}\n\t\n\tfunction onClickHandler (e) : Void {\n\t\tvar temp : DivElement = cast e.currentTarget;\n\t\tif(temp.className.indexOf('left') != -1){\n\t\t\ttrace('left');\n\t\t\tmove(-1);\n\t\t} else {\n\t\t\ttrace('right');\n\t\t\tmove(1);\n\t\t}\n\t}\n\t\n\tfunction onResizeHandler () : Void \n\t{\n\t\t_width = _win.innerWidth;\n\t\t_height = _win.innerHeight; \n\t\t\n\t\t// var divs = _doc.getElementsByClassName(\"slidrr\");\n\t\t// for ( i in 0 ... divs.length ) {\n\t\t// \tvar div : DivElement = cast divs[i];\n\t\t// \tdiv.style.width = Std.string(_width) + 'px';\n\t\t// \tdiv.style.height = Std.string(_height) + 'px';\n\t\t// }\n\t}\n\t\n\t// ____________________________________ read markdown file ____________________________________\n\t\n\tfunction readTextFile(file):Void\n\t{\n\t\tvar rawFile = new XMLHttpRequest();\n\t\trawFile.open(\"GET\", file, false);\n\t\trawFile.onreadystatechange = function ()\n\t\t{\n\t\t\tif(rawFile.readyState == 4)\n\t\t\t{\n\t\t\t\tif(rawFile.status == 200 || rawFile.status == 0)\n\t\t\t\t{\n\t\t\t\t\tvar file = rawFile.responseText;\n\t\t\t\t\tbuild(file);\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\trawFile.send();\n\t}\n\t\n\n\tstatic public function main () {\n\t\tvar app = new Main ();\n\t}\n}","import markdown.AST;\nimport markdown.InlineParser;\nimport markdown.BlockParser;\nimport markdown.HtmlRenderer;\nusing StringTools;\nusing Lambda;\n\nclass Markdown\n{\n\t#if sys\n\tpublic static function main()\n\t{\n\t\tvar args = Sys.args();\n\n\t\tvar last:String = (new haxe.io.Path(args[args.length-1])).toString();\n\t\tvar slash = last.substr(-1);\n\t\tif (slash==\"/\"|| slash==\"\\\\\") \n\t\t\tlast = last.substr(0,last.length-1);\n\t\tif (sys.FileSystem.exists(last) && sys.FileSystem.isDirectory(last)) {\n\t\t\tSys.setCwd(last);\n\t\t}\n\n\t\tvar source = args[0];\n\t\tif (source == \"-f\") source = sys.io.File.getContent(args[1]);\n\t\t\n\t\ttry\n\t\t{\n\t\t\tvar output = markdownToHtml(source);\n\t\t\tSys.print(output);\n\t\t\tSys.exit(0);\n\t\t}\n\t\tcatch (e:Dynamic)\n\t\t{\n\t\t\tSys.print(\"Error: \" + haxe.CallStack.toString(haxe.CallStack.exceptionStack()));\n\t\t\tSys.exit(1);\n\t\t}\n\t}\n\t#end\n\n\tpublic static function markdownToHtml(markdown:String):String\n\t{\n\t\t// create document\n\t\tvar document = new Document();\n\n\t\ttry\n\t\t{\n\t\t\t// replace windows line endings with unix, and split\n\t\t\tvar lines = ~/(\\r\\n|\\r)/g.replace(markdown, '\\n').split(\"\\n\");\n\n\t\t\t// parse ref links\n\t\t\tdocument.parseRefLinks(lines);\n\n\t\t\t// parse ast\n\t\t\tvar blocks = document.parseLines(lines);\n\t\t\treturn renderHtml(blocks);\n\t\t}\n\t\tcatch (e:Dynamic)\n\t\t{\n\t\t\treturn '<pre>$e</pre>';\n\t\t}\n\t}\n\n\tpublic static function renderHtml(blocks:Array<Node>):String\n\t{\n\t\treturn new HtmlRenderer().render(blocks);\n\t}\n}\n\n/**\n\tMaintains the context needed to parse a markdown document.\n**/\nclass Document\n{\n\tpublic var refLinks:Map<String, Link>;\n\tpublic var inlineSyntaxes:Array<InlineSyntax>;\n\tpublic var linkResolver:Resolver;\n\n\tpublic function new()\n\t{\n\t\trefLinks = new Map();\n\t\tinlineSyntaxes = [];\n\t}\n\n\tpublic function parseRefLinks(lines:Array<String>)\n\t{\n\t\t// This is a hideous regex. It matches:\n\t\t// [id]: http:foo.com \"some title\"\n\t\t// Where there may whitespace in there, and where the title may be in\n\t\t// single quotes, double quotes, or parentheses.\n\t\tvar indent = '^[ ]{0,3}';\t// Leading indentation.\n\t\tvar id = '\\\\[([^\\\\]]+)\\\\]';\t// Reference id in [brackets].\n\t\tvar quote = '\"[^\"]+\"';\t\t// Title in \"double quotes\".\n\t\tvar apos = \"'[^']+'\";\t\t// Title in 'single quotes'.\n\t\tvar paren = \"\\\\([^)]+\\\\)\";\t// Title in (parentheses).\n\t\tvar titles =\tnew EReg('($quote|$apos|$paren)', '');\n\t\tvar link = new EReg(\n\t\t\t'$indent$id:\\\\s+(\\\\S+)\\\\s*($quote|$apos|$paren|)\\\\s*$', '');\n\n\n\t\tfor (i in 0...lines.length)\n\t\t{\n\t\t\tif (!link.match(lines[i])) continue;\n\t\t\t\n\t\t\t// Parse the link.\n\t\t\tvar id = link.matched(1);\n\t\t\tvar url = link.matched(2);\n\t\t\tvar title = link.matched(3);\n\t\t\t\n\t\t\tif (url.startsWith('<') && url.endsWith('>'))\n\t\t\t\turl = url.substr(1, url.length - 2);\n\n\t\t\t// next line could be a title, apparently\n\t\t\tif (title == '' && lines[i + 1] != null && titles.match(lines[i + 1]))\n\t\t\t{\n\t\t\t\ttitle = titles.matched(1);\n\t\t\t\tlines[i + 1] = '';\n\t\t\t}\n\n\t\t\tif (title == '')\n\t\t\t{\n\t\t\t\t// No title.\n\t\t\t\ttitle = null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Remove \"\", '', or ().\n\t\t\t\ttitle = title.substring(1, title.length - 1);\n\t\t\t}\n\n\t\t\t// References are case-insensitive.\n\t\t\tid = id.toLowerCase();\n\t\t\trefLinks.set(id, new Link(id, url, title));\n\n\t\t\t// Remove it from the output. We replace it with a blank line which \n\t\t\t// will get consumed by later processing.\n\t\t\tlines[i] = '';\n\t\t}\n\t}\n\n\t/**\n\t\tParse the given [lines] of markdown to a series of AST nodes.\n\t**/\n\tpublic function parseLines(lines:Array<String>):Array<Node>\n\t{\n\t\tvar parser = new BlockParser(lines, this);\n\t\tvar blocks = [];\n\n\t\twhile (!parser.isDone)\n\t\t{\n\t\t\tfor (syntax in BlockSyntax.syntaxes)\n\t\t\t{\n\t\t\t\tif (syntax.canParse(parser))\n\t\t\t\t{\n\t\t\t\t\tvar block = syntax.parse(parser);\n\t\t\t\t\tif (block != null) blocks.push(block);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn blocks;\n\t}\n\n\t/**\n\t\tTakes a string of raw text and processes all inline markdown tags,\n\t\treturning a list of AST nodes. For example, given ``\"*this **is** a*\n\t\t`markdown`\"``, returns:\n\t\t`<em>this <strong>is</strong> a</em> <code>markdown</code>`.\n\t**/\n\tpublic function parseInline(text:String):Array<Node>\n\t{\n\t\treturn new InlineParser(text, this).parse();\n\t}\n}\n\nclass Link\n{\n\tpublic var id(default, null):String;\n\tpublic var url(default, null):String;\n\tpublic var title(default, null):String;\n\n\tpublic function new(id:String, url:String, title:String)\n\t{\n\t\tthis.id = id;\n\t\tthis.url = url;\n\t\tthis.title = title;\n\t}\n}\n\ntypedef Resolver = String -> Node;\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class Reflect {\n\n\tpublic inline static function hasField( o : Dynamic, field : String ) : Bool {\n\t\treturn untyped __js__('Object').prototype.hasOwnProperty.call(o, field);\n\t}\n\n\tpublic static function field( o : Dynamic, field : String ) : Dynamic {\n\t\ttry return untyped o[field] catch( e : Dynamic ) return null;\n\t}\n\n\tpublic inline static function setField( o : Dynamic, field : String, value : Dynamic ) : Void untyped {\n\t\to[field] = value;\n\t}\n\n\tpublic static inline function getProperty( o : Dynamic, field : String ) : Dynamic untyped {\n\t\tvar tmp;\n\t\treturn if( o == null ) __define_feature__(\"Reflect.getProperty\",null) else if( o.__properties__ && (tmp=o.__properties__[\"get_\"+field]) ) o[tmp]() else o[field];\n\t}\n\n\tpublic static inline function setProperty( o : Dynamic, field : String, value : Dynamic ) : Void untyped {\n\t\tvar tmp;\n\t\tif( o.__properties__ && (tmp=o.__properties__[\"set_\"+field]) ) o[tmp](value) else o[field] = __define_feature__(\"Reflect.setProperty\",value);\n\t}\n\n\tpublic inline static function callMethod( o : Dynamic, func : haxe.Constraints.Function, args : Array<Dynamic> ) : Dynamic untyped {\n\t\treturn func.apply(o,args);\n\t}\n\n\tpublic static function fields( o : Dynamic ) : Array<String> {\n\t\tvar a = [];\n\t\tif (o != null) untyped {\n\t\t\tvar hasOwnProperty = __js__('Object').prototype.hasOwnProperty;\n\t\t\t__js__(\"for( var f in o ) {\");\n\t\t\tif( f != \"__id__\" && f != \"hx__closures__\" && hasOwnProperty.call(o, f) ) a.push(f);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static function isFunction( f : Dynamic ) : Bool untyped {\n\t\treturn __js__(\"typeof(f)\") == \"function\" && !(js.Boot.isClass(f) || js.Boot.isEnum(f));\n\t}\n\n\tpublic static function compare<T>( a : T, b : T ) : Int {\n\t\treturn ( a == b ) ? 0 : (((cast a) > (cast b)) ? 1 : -1);\n\t}\n\n\tpublic static function compareMethods( f1 : Dynamic, f2 : Dynamic ) : Bool {\n\t\tif( f1 == f2 )\n\t\t\treturn true;\n\t\tif( !isFunction(f1) || !isFunction(f2) )\n\t\t\treturn false;\n\t\treturn f1.scope == f2.scope && f1.method == f2.method && f1.method != null;\n\t}\n\n\tpublic static function isObject( v : Dynamic ) : Bool untyped {\n\t\tif( v == null )\n\t\t\treturn false;\n\t\tvar t = __js__(\"typeof(v)\");\n\t\treturn (t == \"string\" || (t == \"object\" && v.__enum__ == null)) || (t == \"function\" && (js.Boot.isClass(v) || js.Boot.isEnum(v)) != null);\n\t}\n\n\tpublic static function isEnumValue( v : Dynamic ) : Bool {\n\t\treturn v != null && v.__enum__ != null;\n\t}\n\n\tpublic static function deleteField( o : Dynamic, field : String ) : Bool untyped {\n\t\tif( !hasField(o,field) ) return false;\n\t\t__js__(\"delete\")(o[field]);\n\t\treturn true;\n\t}\n\n\tpublic static function copy<T>( o : T ) : T {\n\t\tvar o2 : Dynamic = {};\n\t\tfor( f in Reflect.fields(o) )\n\t\t\tReflect.setField(o2,f,Reflect.field(o,f));\n\t\treturn o2;\n\t}\n\n\t@:overload(function( f : Array<Dynamic> -> Void ) : Dynamic {})\n\tpublic static function makeVarArgs( f : Array<Dynamic> -> Dynamic ) : Dynamic {\n\t\treturn function() {\n\t\t\tvar a = untyped Array.prototype.slice.call(__js__(\"arguments\"));\n\t\t\treturn f(a);\n\t\t};\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nimport js.Boot;\n\n@:keepInit\n@:coreApi class Std {\n\n\tpublic static inline function is( v : Dynamic, t : Dynamic ) : Bool {\n\t\treturn untyped js.Boot.__instanceof(v,t);\n\t}\n\n\tpublic static inline function instance<T:{},S:T>( value : T, c : Class<S> ) : S {\n\t\treturn untyped __instanceof__(value, c) ? cast value : null;\n\t}\n\n\tpublic static function string( s : Dynamic ) : String {\n\t\treturn untyped js.Boot.__string_rec(s,\"\");\n\t}\n\n\tpublic static inline function int( x : Float ) : Int {\n\t\treturn (cast x) | 0;\n\t}\n\n\tpublic static function parseInt( x : String ) : Null<Int> {\n\t\tvar v = untyped __js__(\"parseInt\")(x, 10);\n\t\t// parse again if hexadecimal\n\t\tif( v == 0 && (x.charCodeAt(1) == 'x'.code || x.charCodeAt(1) == 'X'.code) )\n\t\t\tv = untyped __js__(\"parseInt\")(x);\n\t\tif( untyped __js__(\"isNaN\")(v) )\n\t\t\treturn null;\n\t\treturn cast v;\n\t}\n\n\tpublic static inline function parseFloat( x : String ) : Float {\n\t\treturn untyped __js__(\"parseFloat\")(x);\n\t}\n\n\tpublic static function random( x : Int ) : Int {\n\t\treturn untyped x <= 0 ? 0 : Math.floor(Math.random()*x);\n\t}\n\n\tstatic function __init__() : Void untyped {\n\t\t__feature__(\"js.Boot.getClass\",String.prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"String\"] = String,String));\n\t\t__feature__(\"js.Boot.isClass\",String.__name__ = __feature__(\"Type.getClassName\",[\"String\"],true));\n\t\t__feature__(\"Type.resolveClass\",$hxClasses[\"Array\"] = Array);\n\t\t__feature__(\"js.Boot.isClass\",Array.__name__ = __feature__(\"Type.getClassName\",[\"Array\"],true));\n\t\t__feature__(\"Date.*\", {\n\t\t\t__feature__(\"js.Boot.getClass\",__js__('Date').prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"Date\"] = __js__('Date'),__js__('Date')));\n\t\t\t__feature__(\"js.Boot.isClass\",__js__('Date').__name__ = [\"Date\"]);\n\t\t});\n\t\t__feature__(\"Int.*\",{\n\t\t\tvar Int = __feature__(\"Type.resolveClass\", $hxClasses[\"Int\"] = { __name__ : [\"Int\"] }, { __name__ : [\"Int\"] });\n\t\t});\n\t\t__feature__(\"Dynamic.*\",{\n\t\t\tvar Dynamic = __feature__(\"Type.resolveClass\", $hxClasses[\"Dynamic\"] = { __name__ : [\"Dynamic\"] }, { __name__ : [\"Dynamic\"] });\n\t\t});\n\t\t__feature__(\"Float.*\",{\n\t\t\tvar Float = __feature__(\"Type.resolveClass\", $hxClasses[\"Float\"] = __js__(\"Number\"), __js__(\"Number\"));\n\t\t\tFloat.__name__ = [\"Float\"];\n\t\t});\n\t\t__feature__(\"Bool.*\",{\n\t\t\tvar Bool = __feature__(\"Type.resolveEnum\",$hxClasses[\"Bool\"] = __js__(\"Boolean\"), __js__(\"Boolean\"));\n\t\t\tBool.__ename__ = [\"Bool\"];\n\t\t});\n\t\t__feature__(\"Class.*\",{\n\t\t\tvar Class = __feature__(\"Type.resolveClass\", $hxClasses[\"Class\"] = { __name__ : [\"Class\"] }, { __name__ : [\"Class\"] });\n\t\t});\n\t\t__feature__(\"Enum.*\",{\n\t\t\tvar Enum = {};\n\t\t});\n\t\t__feature__(\"Void.*\",{\n\t\t\tvar Void = __feature__(\"Type.resolveEnum\", $hxClasses[\"Void\"] = { __ename__ : [\"Void\"] }, { __ename__ : [\"Void\"] });\n\t\t});\n\n#if !js_es5\n\t\t__feature__(\"Array.map\",\n\t\t\tif( Array.prototype.map == null )\n\t\t\t\tArray.prototype.map = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length )\n\t\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n\t\t__feature__(\"Array.filter\",\n\t\t\tif( Array.prototype.filter == null )\n\t\t\t\tArray.prototype.filter = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length ) {\n\t\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\t\tif( f(e) ) a.push(e);\n\t\t\t\t\t}\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tA String buffer is an efficient way to build a big string by appending small\n\telements together.\n\n\tIts cross-platform implementation uses String concatenation internally, but\n\tStringBuf may be optimized for different targets.\n\n\tUnlike String, an instance of StringBuf is not immutable in the sense that\n\tit can be passed as argument to functions which modify it by appending more\n\tvalues. However, the internal buffer cannot be modified.\n**/\nclass StringBuf {\n\n\tvar b:String;\n\n\t/**\n\t\tThe length of `this` StringBuf in characters.\n\t**/\n\tpublic var length(get,never) : Int;\n\n\t/**\n\t\tCreates a new StringBuf instance.\n\n\t\tThis may involve initialization of the internal buffer.\n\t**/\n\tpublic inline function new() {\n\t\tb = \"\";\n\t}\n\n\tinline function get_length() : Int {\n\t\treturn b.length;\n\t}\n\n\t/**\n\t\tAppends the representation of `x` to `this` StringBuf.\n\n\t\tThe exact representation of `x` may vary per platform. To get more\n\t\tconsistent behavior, this function should be called with\n\t\tStd.string(x).\n\n\t\tIf `x` is null, the String \"null\" is appended.\n\t**/\n\tpublic inline function add<T>( x : T ) : Void {\n\t\tb += x;\n\t}\n\n\t/**\n\t\tAppends the character identified by `c` to `this` StringBuf.\n\n\t\tIf `c` is negative or has another invalid value, the result is\n\t\tunspecified.\n\t**/\n\tpublic inline function addChar( c : Int ) : Void {\n\t\tb += String.fromCharCode(c);\n\t}\n\n\t/**\n\t\tAppends a substring of `s` to `this` StringBuf.\n\n\t\tThis function expects `pos` and `len` to describe a valid substring of\n\t\t`s`, or else the result is unspecified. To get more robust behavior,\n\t\t`this.add(s.substr(pos,len))` can be used instead.\n\n\t\tIf `s` or `pos` are null, the result is unspecified.\n\n\t\tIf `len` is omitted or null, the substring ranges from `pos` to the end\n\t\tof `s`.\n\t**/\n\tpublic inline function addSub( s : String, pos : Int, ?len : Int) : Void {\n\t\tb += (len == null ? s.substr(pos) : s.substr(pos, len));\n\t}\n\n\t/**\n\t\tReturns the content of `this` StringBuf as String.\n\n\t\tThe buffer is not emptied by this operation.\n\t**/\n\tpublic inline function toString() : String {\n\t\treturn b;\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tThis class provides advanced methods on Strings. It is ideally used with\n\t'using StringTools' and then acts as an extension to the String class.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.\n**/\n#if cpp\nusing cpp.NativeString;\n#end\nclass StringTools {\n\t/**\n\t\tEncode an URL by using the standard format.\n\t**/\n\t#if (!java && !cpp) inline #end public static function urlEncode( s : String ) : String {\n\t\t#if flash\n\t\t\treturn untyped __global__[\"encodeURIComponent\"](s);\n\t\t#elseif neko\n\t\t\treturn untyped new String(_urlEncode(s.__s));\n\t\t#elseif js\n\t\t\treturn untyped encodeURIComponent(s);\n\t\t#elseif cpp\n\t\t\treturn untyped s.__URLEncode();\n\t\t#elseif java\n\t\t\ttry\n\t\t\t\treturn untyped __java__(\"java.net.URLEncoder.encode(s, \\\"UTF-8\\\")\")\n\t\t\tcatch (e:Dynamic) throw e;\n\t\t#elseif cs\n\t\t\treturn untyped cs.system.Uri.EscapeDataString(s);\n\t\t#elseif python\n\t\t\treturn python.lib.urllib.Parse.quote(s, \"\");\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n\t/**\n\t\tDecode an URL using the standard format.\n\t**/\n\t#if (!java && !cpp) inline #end public static function urlDecode( s : String ) : String {\n\t\t#if flash\n\t\t\treturn untyped __global__[\"decodeURIComponent\"](s.split(\"+\").join(\" \"));\n\t\t#elseif neko\n\t\t\treturn untyped new String(_urlDecode(s.__s));\n\t\t#elseif js\n\t\t\treturn untyped decodeURIComponent(s.split(\"+\").join(\" \"));\n\t\t#elseif cpp\n\t\t\treturn untyped s.__URLDecode();\n\t\t#elseif java\n\t\t\ttry\n\t\t\t\treturn untyped __java__(\"java.net.URLDecoder.decode(s, \\\"UTF-8\\\")\")\n\t\t\tcatch (e:Dynamic) throw e;\n\t\t#elseif cs\n\t\t\treturn untyped cs.system.Uri.UnescapeDataString(s);\n\t\t#elseif python\n\t\t\treturn python.lib.urllib.Parse.unquote(s);\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n\t/**\n\t\tEscapes HTML special characters of the string `s`.\n\n\t\tThe following replacements are made:\n\n\t\t- `&` becomes `&amp`;\n\t\t- `<` becomes `&lt`;\n\t\t- `>` becomes `&gt`;\n\n\t\tIf `quotes` is true, the following characters are also replaced:\n\n\t\t- `\"` becomes `&quot`;\n\t\t- `'` becomes `&#039`;\n\t**/\n\tpublic static function htmlEscape( s : String, ?quotes : Bool ) : String {\n\t\ts = s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t\treturn quotes ? s.split('\"').join(\"&quot;\").split(\"'\").join(\"&#039;\") : s;\n\t}\n\n\t/**\n\t\tUnescapes HTML special characters of the string `s`.\n\n\t\tThis is the inverse operation to htmlEscape, i.e. the following always\n\t\tholds: htmlUnescape(htmlEscape(s)) == s\n\n\t\tThe replacements follow:\n\n\t\t- `&amp;` becomes `&`\n\t\t- `&lt;` becomes `<`\n\t\t- `&gt;` becomes `>`\n\t\t- `&quot;` becomes `\"`\n\t\t- `&#039;` becomes `'`\n\t**/\n\tpublic static function htmlUnescape( s : String ) : String {\n\t\treturn s.split(\"&gt;\").join(\">\").split(\"&lt;\").join(\"<\").split(\"&quot;\").join('\"').split(\"&#039;\").join(\"'\").split(\"&amp;\").join(\"&\");\n\t}\n\n\t/**\n\t\tTells if the string `s` starts with the string `start`.\n\n\t\tIf `start` is null, the result is unspecified.\n\n\t\tIf `start` is the empty String \"\", the result is true.\n\t**/\n\tpublic static #if (cs || java) inline #end function startsWith( s : String, start : String ) : Bool {\n\t\t#if java\n\t\treturn untyped s.startsWith(start);\n\t\t#elseif cs\n\t\treturn untyped s.StartsWith(start);\n\t\t#elseif cpp\n\t\tif (s.length<start.length)\n\t\t\treturn false;\n\t\tvar p0 = s.c_str();\n\t\tvar p1 = start.c_str();\n\t\tfor(i in 0...start.length)\n\t\t\tif ( p0.at(i) != p1.at(i) )\n\t\t\t\treturn false;\n\t\treturn true;\n\t\t#else\n\t\treturn( s.length >= start.length && s.substr(0, start.length) == start );\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the string `s` ends with the string `end`.\n\n\t\tIf `end` is null, the result is unspecified.\n\n\t\tIf `end` is the empty String \"\", the result is true.\n\t**/\n\tpublic static #if (cs || java) inline #end function endsWith( s : String, end : String ) : Bool {\n\t\t#if java\n\t\treturn untyped s.endsWith(end);\n\t\t#elseif cs\n\t\treturn untyped s.EndsWith(end);\n\t\t#elseif cpp\n\t\tif (s.length<end.length)\n\t\t\treturn false;\n\t\tvar p0 = s.c_str().add( s.length-end.length );\n\t\tvar p1 = end.c_str();\n\t\tfor(i in 0...end.length)\n\t\t\tif ( p0.at(i) != p1.at(i) )\n\t\t\t\treturn false;\n\t\treturn true;\n\t\t#else\n\t\tvar elen = end.length;\n\t\tvar slen = s.length;\n\t\treturn( slen >= elen && s.substr(slen - elen, elen) == end );\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the character in the string `s` at position `pos` is a space.\n\n\t\tA character is considered to be a space character if its character code\n\t\tis 9,10,11,12,13 or 32.\n\n\t\tIf `s` is the empty String \"\", or if pos is not a valid position within\n\t\t`s`, the result is false.\n\t**/\n\tpublic static function isSpace( s : String, pos : Int ) : Bool {\n\t\t#if python\n\t\tif (s.length == 0 || pos < 0 || pos >= s.length) return false;\n\t\t#end\n\t\tvar c = s.charCodeAt( pos );\n\t\treturn (c > 8 && c < 14) || c == 32;\n\t}\n\n\t/**\n\t\tRemoves leading space characters of `s`.\n\n\t\tThis function internally calls isSpace() to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String \"\" or consists only of space characters, the\n\t\tresult is the empty String \"\".\n\t**/\n\tpublic #if cs inline #end static function ltrim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.TrimStart();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile( r < l && isSpace(s,r) ){\n\t\t\tr++;\n\t\t}\n\t\tif( r > 0 )\n\t\t\treturn s.substr(r, l-r);\n\t\telse\n\t\t\treturn s;\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves trailing space characters of `s`.\n\n\t\tThis function internally calls isSpace() to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String \"\" or consists only of space characters, the\n\t\tresult is the empty String \"\".\n\t**/\n\tpublic #if cs inline #end static function rtrim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.TrimEnd();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile( r < l && isSpace(s,l-r-1) ){\n\t\t\tr++;\n\t\t}\n\t\tif( r > 0 ){\n\t\t\treturn s.substr(0, l-r);\n\t\t}else{\n\t\t\treturn s;\n\t\t}\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves leading and trailing space characters of `s`.\n\n\t\tThis is a convenience function for ltrim(rtrim(s)).\n\t**/\n\tpublic #if (cs || java) inline #end static function trim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.Trim();\n\t\t#elseif java\n\t\treturn untyped s.trim();\n\t\t#else\n\t\treturn ltrim(rtrim(s));\n\t\t#end\n\t}\n\n\t/**\n\t\tConcatenates `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String \"\" or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function lpad( s : String, c : String, l : Int ) : String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\twhile (s.length < l) {\n\t\t\ts = c + s;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tAppends `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String \"\" or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function rpad( s : String, c : String, l : Int ) : String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\twhile (s.length < l) {\n\t\t\ts = s + c;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReplace all occurences of the String `sub` in the String `s` by the\n\t\tString `by`.\n\n\t\tIf `sub` is the empty String \"\", `by` is inserted after each character\n\t\tof `s`. If `by` is also the empty String \"\", `s` remains unchanged.\n\n\t\tThis is a convenience function for `s.split(sub).join(by)`.\n\n\t\tIf `sub` or `by` are null, the result is unspecified.\n\t**/\n\tpublic static function replace( s : String, sub : String, by : String ) : String {\n\t\t#if java\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.replace(sub, by);\n\t\t#elseif cs\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.Replace(sub, by);\n\t\t#else\n\t\treturn s.split(sub).join(by);\n\t\t#end\n\t}\n\n\t/**\n\t\tEncodes `n` into a hexadecimal representation.\n\n\t\tIf `digits` is specified, the resulting String is padded with \"0\" until\n\t\tits length equals `digits`.\n\t**/\n\tpublic static function hex( n : Int, ?digits : Int ) {\n\t\t#if flash\n\t\t\tvar n : UInt = n;\n\t\t\tvar s : String = untyped n.toString(16);\n\t\t\ts = s.toUpperCase();\n\t\t#else\n\t\t\tvar s = \"\";\n\t\t\tvar hexChars = \"0123456789ABCDEF\";\n\t\t\tdo {\n\t\t\t\ts = hexChars.charAt(n&15) + s;\n\t\t\t\tn >>>= 4;\n\t\t\t} while( n > 0 );\n\t\t#end\n\t\t#if python\n\t\tif (digits != null && s.length < digits) {\n\t\t\tvar diff = digits - s.length;\n\t\t\tfor (_ in 0...diff) {\n\t\t\t\ts = \"0\" + s;\n\t\t\t}\n\t\t}\n\t\t#else\n\t\tif( digits != null )\n\t\t\twhile( s.length < digits )\n\t\t\t\ts = \"0\"+s;\n\t\t#end\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReturns the character code at position `index` of String `s`, or an\n\t\tend-of-file indicator at if `position` equals `s.length`.\n\n\t\tThis method is faster than String.charCodeAt() on some platforms, but\n\t\tthe result is unspecified if `index` is negative or greater than\n\t\t`s.length`.\n\n\t\tEnd of file status can be checked by calling `StringTools.isEof` with\n\t\tthe returned value as argument.\n\n\t\tThis operation is not guaranteed to work if `s` contains the \\0\n\t\tcharacter.\n\t**/\n\tpublic static inline function fastCodeAt( s : String, index : Int ) : Int {\n\t\t#if neko\n\t\treturn untyped __dollar__sget(s.__s, index);\n\t\t#elseif cpp\n\t\treturn untyped s.cca(index);\n\t\t#elseif flash\n\t\treturn untyped s.cca(index);\n\t\t#elseif java\n\t\treturn ( index < s.length ) ? cast(_charAt(s, index), Int) : -1;\n\t\t#elseif cs\n\t\treturn ( cast(index, UInt) < s.length ) ? cast(s[index], Int) : -1;\n\t\t#elseif js\n\t\treturn (untyped s).charCodeAt(index);\n\t\t#elseif python\n\t\treturn if (index >= s.length) -1 else python.internal.UBuiltins.ord(python.Syntax.arrayAccess(s, index));\n\t\t#else\n\t\treturn untyped s.cca(index);\n\t\t#end\n\t}\n\n\t/*\n\t\tTells if `c` represents the end-of-file (EOF) character.\n\t*/\n\t@:noUsing public static inline function isEof( c : Int ) : Bool {\n\t\t#if (flash || cpp)\n\t\treturn c == 0;\n\t\t#elseif js\n\t\treturn c != c; // fast NaN\n\t\t#elseif neko\n\t\treturn c == null;\n\t\t#elseif cs\n\t\treturn c == -1;\n\t\t#elseif java\n\t\treturn c == -1;\n\t\t#elseif python\n\t\treturn c == -1;\n\t\t#else\n\t\treturn false;\n\t\t#end\n\t}\n\n\t#if java\n\tprivate static inline function _charAt(str:String, idx:Int):java.StdTypes.Char16 return untyped str._charAt(idx);\n\t#end\n\n\t#if neko\n\tprivate static var _urlEncode = neko.Lib.load(\"std\",\"url_encode\",1);\n\tprivate static var _urlDecode = neko.Lib.load(\"std\",\"url_decode\",1);\n\t#end\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.ds;\n\nprivate class StringMapIterator<T> {\n\tvar map : StringMap<T>;\n\tvar keys : Array<String>;\n\tvar index : Int;\n\tvar count : Int;\n\tpublic inline function new(map:StringMap<T>, keys:Array<String>) {\n\t\tthis.map = map;\n\t\tthis.keys = keys;\n\t\tthis.index = 0;\n\t\tthis.count = keys.length;\n\t}\n\tpublic inline function hasNext() {\n\t\treturn index < count;\n\t}\n\tpublic inline function next() {\n\t\treturn map.get(keys[index++]);\n\t}\n}\n\n@:coreApi class StringMap<T> implements haxe.Constraints.IMap<String,T> {\n\n\tprivate var h : Dynamic;\n\tprivate var rh : Dynamic;\n\n\tpublic inline function new() : Void {\n\t\th = {};\n\t}\n\n\tinline function isReserved(key:String) : Bool {\n\t\treturn untyped __js__(\"__map_reserved\")[key] != null;\n\t}\n\n\tpublic inline function set( key : String, value : T ) : Void {\n\t\tif( isReserved(key) )\n\t\t\tsetReserved(key, value);\n\t\telse\n\t\t\th[cast key] = value;\n\t}\n\n\tpublic inline function get( key : String ) : Null<T> {\n\t\tif( isReserved(key) )\n\t\t\treturn getReserved(key);\n\t\treturn h[cast key];\n\t}\n\n\tpublic inline function exists( key : String ) : Bool {\n\t\tif( isReserved(key) )\n\t\t\treturn existsReserved(key);\n\t\treturn h.hasOwnProperty(key);\n\t}\n\n\tfunction setReserved( key : String, value : T ) : Void {\n\t\tif( rh == null ) rh = {};\n\t\trh[cast \"$\"+key] = value;\n\t}\n\n\tfunction getReserved( key : String ) : Null<T> {\n\t\treturn rh == null ? null : rh[cast \"$\"+key];\n\t}\n\n\tfunction existsReserved( key : String ) : Bool {\n\t\tif( rh == null ) return false;\n\t\treturn untyped rh.hasOwnProperty(\"$\"+key);\n\t}\n\n\tpublic function remove( key : String ) : Bool {\n\t\tif( isReserved(key) ) {\n\t\t\tkey = \"$\" + key;\n\t\t\tif( rh == null || !rh.hasOwnProperty(key) ) return false;\n\t\t\tuntyped __js__(\"delete\")(rh[key]);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tif( !h.hasOwnProperty(key) )\n\t\t\t\treturn false;\n\t\t\tuntyped __js__(\"delete\")(h[key]);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tpublic function keys() : Iterator<String> {\n\t\treturn arrayKeys().iterator();\n\t}\n\t\n\tfunction arrayKeys() : Array<String> {\n\t\tvar out = [];\n\t\tuntyped {\n\t\t\t__js__(\"for( var key in this.h ) {\");\n\t\t\t\tif( h.hasOwnProperty(key) )\n\t\t\t\t\tout.push(key);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\tif( rh != null ) untyped {\n\t\t\t__js__(\"for( var key in this.rh ) {\");\n\t\t\t\tif( key.charCodeAt(0) == \"$\".code )\n\t\t\t\t\tout.push(key.substr(1));\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn out;\n\t}\n\n\tpublic inline function iterator() : Iterator<T> {\n\t\treturn new StringMapIterator(this, arrayKeys());\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar keys = arrayKeys();\n\t\tfor( i in 0...keys.length ) {\n\t\t\tvar k = keys[i];\n\t\t\ts.add(k);\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(k)));\n\t\t\tif( i < keys.length )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n\tstatic function __init__() : Void {\n\t\tuntyped __js__(\"var __map_reserved = {}\");\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js;\n\nprivate class HaxeError extends js.Error {\n\n\tvar val:Dynamic;\n\n\tpublic function new(val:Dynamic) untyped {\n\t\tsuper();\n\t\tthis.val = __define_feature__(\"js.Boot.HaxeError\", val);\n\t\tthis.message = String(val);\n\t\tif (js.Error.captureStackTrace) js.Error.captureStackTrace(this, HaxeError);\n\t}\n}\n\n@:dox(hide)\nclass Boot {\n\n\tprivate static function __unhtml(s : String) {\n\t\treturn s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t}\n\n\tprivate static function __trace(v,i : haxe.PosInfos) {\n\t\tuntyped {\n\t\t\tvar msg = if( i != null ) i.fileName+\":\"+i.lineNumber+\": \" else \"\";\n\t\t\t#if jsfl\n\t\t\tmsg += __string_rec(v,\"\");\n\t\t\tfl.trace(msg);\n\t\t\t#else\n\t\t\tmsg += __string_rec(v, \"\");\n\t\t\tif( i != null && i.customParams != null )\n\t\t\t\tfor( v in i.customParams )\n\t\t\t\t\tmsg += \",\" + __string_rec(v, \"\");\n\t\t\tvar d;\n\t\t\tif( __js__(\"typeof\")(document) != \"undefined\" && (d = document.getElementById(\"haxe:trace\")) != null )\n\t\t\t\td.innerHTML += __unhtml(msg)+\"<br/>\";\n\t\t\telse if( __js__(\"typeof console\") != \"undefined\" && __js__(\"console\").log != null )\n\t\t\t\t__js__(\"console\").log(msg);\n\t\t\t#end\n\t\t}\n\t}\n\n\tprivate static function __clear_trace() {\n\t\tuntyped {\n\t\t\t#if jsfl\n\t\t\tfl.outputPanel.clear();\n\t\t\t#else\n\t\t\tvar d = document.getElementById(\"haxe:trace\");\n\t\t\tif( d != null )\n\t\t\t\td.innerHTML = \"\";\n\t\t\t#end\n\t\t}\n\t}\n\n\tstatic inline function isClass(o:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\tstatic function getClass(o:Dynamic) : Dynamic {\n\t\tif (Std.is(o, Array))\n\t\t\treturn Array;\n\t\telse {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"has_enum\")\n\tprivate static function __string_rec(o,s:String) {\n\t\tuntyped {\n\t\t\tif( o == null )\n\t\t\t    return \"null\";\n\t\t\tif( s.length >= 5 )\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = __js__(\"typeof(o)\");\n\t\t\tif( t == \"function\" && (isClass(o) || isEnum(o)) )\n\t\t\t\tt = \"object\";\n\t\t\tswitch( t ) {\n\t\t\tcase \"object\":\n\t\t\t\tif( __js__(\"o instanceof Array\") ) {\n\t\t\t\t\tif( o.__enum__ ) {\n\t\t\t\t\t\tif( o.length == 2 )\n\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\tvar str = o[0]+\"(\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor( i in 2...o.length ) {\n\t\t\t\t\t\t\tif( i != 2 )\n\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i],s);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tstr += __string_rec(o[i],s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t}\n\t\t\t\t\tvar l = o.length;\n\t\t\t\t\tvar i;\n\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tfor( i in 0...l )\n\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\")+__string_rec(o[i],s);\n\t\t\t\t\tstr += \"]\";\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t\tvar tostr;\n\t\t\t\ttry {\n\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t} catch( e : Dynamic ) {\n\t\t\t\t\t// strange error on IE\n\t\t\t\t\treturn \"???\";\n\t\t\t\t}\n\t\t\t\tif( tostr != null && tostr != __js__(\"Object.toString\") && __typeof__(tostr) == \"function\" ) {\n\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\tif( s2 != \"[object Object]\")\n\t\t\t\t\t\treturn s2;\n\t\t\t\t}\n\t\t\t\tvar k : String = null;\n\t\t\t\tvar str = \"{\\n\";\n\t\t\t\ts += \"\\t\";\n\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t__js__(\"for( var k in o ) {\");\n\t\t\t\t\tif( hasp && !o.hasOwnProperty(k) )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\" )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( str.length != 2 )\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \"+__string_rec(o[k],s);\n\t\t\t\t__js__(\"}\");\n\t\t\t\ts = s.substring(1);\n\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\treturn str;\n\t\t\tcase \"function\":\n\t\t\t\treturn \"<function>\";\n\t\t\tcase \"string\":\n\t\t\t\treturn o;\n\t\t\tdefault:\n\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static function __interfLoop(cc : Dynamic,cl : Dynamic) {\n\t\tif( cc == null )\n\t\t\treturn false;\n\t\tif( cc == cl )\n\t\t\treturn true;\n\t\tvar intf : Dynamic = cc.__interfaces__;\n\t\tif( intf != null )\n\t\t\tfor( i in 0...intf.length ) {\n\t\t\t\tvar i : Dynamic = intf[i];\n\t\t\t\tif( i == cl || __interfLoop(i,cl) )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\treturn __interfLoop(cc.__super__,cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") private static function __instanceof(o : Dynamic,cl : Dynamic) {\n\t\tif( cl == null )\n\t\t\treturn false;\n\t\tswitch( cl ) {\n\t\tcase Int:\n\t\t\treturn (untyped __js__(\"(o|0) === o\"));\n\t\tcase Float:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"number\";\n\t\tcase Bool:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"boolean\";\n\t\tcase String:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"string\";\n\t\tcase Array:\n\t\t\treturn (untyped __js__(\"(o instanceof Array)\")) && o.__enum__ == null;\n\t\tcase Dynamic:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tif( o != null ) {\n\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\tif( (untyped __js__(\"typeof\"))(cl) == \"function\" ) {\n\t\t\t\t\tif( untyped __js__(\"o instanceof cl\") )\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif( __interfLoop(getClass(o),cl) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if ( (untyped __js__(\"typeof\"))(cl) == \"object\" && __isNativeObj(cl) ) {\n\t\t\t\t\tif( untyped __js__(\"o instanceof cl\") )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// do not use isClass/isEnum here\n\t\t\tuntyped __feature__(\"Class.*\",if( cl == Class && o.__name__ != null ) return true);\n\t\t\tuntyped __feature__(\"Enum.*\",if( cl == Enum && o.__ename__ != null ) return true);\n\t\t\treturn o.__enum__ == cl;\n\t\t}\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o : Dynamic, t : Dynamic) {\n\t\tif (__instanceof(o, t)) return o;\n\t\telse throw \"Cannot cast \" +Std.string(o) + \" to \" +Std.string(t);\n\t}\n\n\tstatic var __toStr = untyped __js__(\"{}.toString\");\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name = untyped __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class in the global scope:\n\tstatic function __resolveNativeClass(name:String) {\n\t\treturn untyped js.Lib.global[name];\n\t}\n\n}\n","package markdown;\n\n/**\n\tBase class for any AST item. Roughly corresponds to Node in the DOM. Will\n\tbe either an ElementNode or TextNode.\n**/\ninterface Node\n{\n\tfunction accept(visitor:NodeVisitor):Void;\n}\n\n/**\n\tVisitor pattern for the AST. Renderers or other AST transformers should\n\timplement this.\n**/\ninterface NodeVisitor\n{\n\t/**\n\t\tCalled when a TextNode has been reached.\n\t**/\n\tfunction visitText(text:TextNode):Void;\n\n\t/**\n\t\tCalled when an ElementNode has been reached, before its children have been\n\t\tvisited. Return `false` to skip its children.\n\t**/\n\tfunction visitElementBefore(element:ElementNode):Bool;\n\n\t/**\n\t\tCalled when an ElementNode has been reached, after its children have been\n\t\tvisited. Will not be called if [visitElementBefore] returns `false`.\n\t**/\n\tfunction visitElementAfter(element:ElementNode):Void;\n}\n\n/**\n\tA named tag that can contain other nodes.\n**/\nclass ElementNode implements Node\n{\n\tpublic static function empty(tag:String):ElementNode\n\t{\n\t\treturn new ElementNode(tag, null);\n\t}\n\n\tpublic static function withTag(tag:String):ElementNode\n\t{\n\t\treturn new ElementNode(tag, []);\n\t}\n\n\tpublic static function text(tag:String, text:String):ElementNode\n\t{\n\t\treturn new ElementNode(tag, [new TextNode(text)]);\n\t}\n\n\tpublic var tag(default, null):String;\n\tpublic var children(default, null):Array<Node>;\n\tpublic var attributes(default, null):Map<String, String>;\n\n\tpublic function new(tag:String, children:Array<Node>)\n\t{\n\t\tthis.tag = tag;\n\t\tthis.children = children;\n\t\tthis.attributes = new Map();\n\t}\n\n\tinline public function isEmpty():Bool\n\t{\n\t\treturn children == null;\n\t}\n\n\tpublic function accept(visitor:NodeVisitor):Void\n\t{\n\t\tif (visitor.visitElementBefore(this))\n\t\t{\n\t\t\tfor (child in children) child.accept(visitor);\n\t\t\tvisitor.visitElementAfter(this);\n\t\t}\n\t}\n}\n\n/**\n\tA plain text element.\n**/\nclass TextNode implements Node\n{\n\tpublic var text(default, null):String;\n\n\tpublic function new(text:String) this.text = text;\n\n\tpublic function accept(visitor:NodeVisitor):Void\n\t{\n\t\tvisitor.visitText(this);\n\t}\n}\n","package markdown;\n\nimport markdown.AST;\nimport Markdown;\nusing StringTools;\nusing Lambda;\n\n/**\n\tMaintains the internal state needed to parse a series of lines into blocks\n\tof markdown suitable for further inline parsing.\n**/\nclass BlockParser\n{\n\t// the lines being parsed\n\tpublic var lines(default, null):Array<String>;\n\n\t// The markdown document this parser is parsing.\n\tpublic var document(default, null):Document;\n\n\t// Index of the current line.\n\tpublic var pos(default, null):Int;\n\n\tpublic function new(lines:Array<String>, document:Document)\n\t{\n\t\tthis.lines = lines;\n\t\tthis.document = document;\n\t\tthis.pos = 0;\n\t}\n\n\t// Gets the current line.\n\tpublic var current(get, never):String;\n\tinline function get_current() return lines[pos];\n\n\t// Gets the line after the current one or `null` if there is none.\n\tpublic var next(get, never):String;\n\tfunction get_next()\n\t{\n\t\t// Don't read past the end.\n\t\tif (pos >= lines.length - 1) return null;\n\t\treturn lines[pos + 1];\n\t}\n\n\t// Move to the next line.\n\tpublic function advance():Void pos++;\n\n\t// Are we there yet?\n\tpublic var isDone(get, never):Bool;\n\tinline function get_isDone() return pos >= lines.length;\n\n\t// Gets whether or not the current line matches the given pattern.\n\tpublic function matches(ereg:EReg):Bool\n\t{\n\t\tif (isDone) return false;\n\t\treturn ereg.match(current);\n\t}\n\n\t// Gets whether or not the current line matches the given pattern.\n\tpublic function matchesNext(ereg:EReg):Bool\n\t{\n\t\tif (next == null) return false;\n\t\treturn ereg.match(next);\n\t}\n}\n\nclass BlockSyntax\n{\n\t/**\n\t\tThe line contains only whitespace or is empty.\n\t**/\n\tstatic var RE_EMPTY = new EReg('^([ \\\\t]*)$', '');\n\n\t/**\n\t\tA series of `=` or `-` (on the next line) define setext-style headers.\n\t**/\n\tstatic var RE_SETEXT = new EReg('^((=+)|(-+))$', '');\n\n\t/**\n\t\tLeading (and trailing) `#` define atx-style headers.\n\t**/\n\tstatic var RE_HEADER = new EReg('^(#{1,6})(.*?)#*$', '');\n\n\t/**\n\t\tThe line starts with `>` with one optional space after.\n\t**/\n\tstatic var RE_BLOCKQUOTE = new EReg('^[ ]{0,3}>[ ]?(.*)$', '');\n\n\t/**\n\t\tA line indented four spaces. Used for code blocks and lists.\n\t**/\n\tstatic var RE_INDENT = new EReg('^(?:    |\\t)(.*)$', '');\n\n\t/**\n\t\tGitHub style triple quoted code block.\n\t**/\n\tstatic var RE_CODE = new EReg('^```(\\\\w*)\\\\s*$', '');\n\n\t/**\n\t\tThree or more hyphens, asterisks or underscores by themselves. Note that\n\t\ta line like `----` is valid as both HR and SETEXT. In case of a tie,\n\t\tSETEXT should win.\n\t**/\n\tstatic var RE_HR = new EReg('^[ ]{0,3}((-+[ ]{0,2}){3,}|(_+[ ]{0,2}){3,}|(\\\\*+[ ]{0,2}){3,})$', '');\n\n\t/**\n\t\tReally hacky way to detect block-level embedded HTML. Just looks for\n\t\t\"<somename\".\n\t**/\n\tstatic var RE_HTML = new EReg('^<[ ]*\\\\w+[ >]', '');\n\n\t/**\n\t\tA line starting with one of these markers: `-`, `*`, `+`. May have up to\n\t\tthree leading spaces before the marker and any number of spaces or tabs\n\t\tafter.\n\t**/\n\tstatic var RE_UL = new EReg('^[ ]{0,3}[*+-][ \\\\t]+(.*)$', '');\n\t\n\t/**\n\t\tA line starting with a number like `123.`. May have up to three leading\n\t\tspaces before the marker and any number of spaces or tabs after.\n\t**/\n\tstatic var RE_OL = new EReg('^[ ]{0,3}\\\\d+\\\\.[ \\\\t]+(.*)$', '');\n\n\t/**\n\t\tGets the collection of built-in block parsers. To turn a series of lines\n\t\tinto blocks, each of these will be tried in turn. Order matters here.\n\t**/\n\tpublic static var syntaxes(get, null):Array<BlockSyntax>;\n\n\tstatic function get_syntaxes():Array<BlockSyntax>\n\t{\n\t\tif (syntaxes == null)\n\t\t{\n\t\t\tsyntaxes = [\n\t\t\t\tnew EmptyBlockSyntax(),\n\t\t\t\tnew BlockHtmlSyntax(),\n\t\t\t\tnew SetextHeaderSyntax(),\n\t\t\t\tnew HeaderSyntax(),\n\t\t\t\tnew CodeBlockSyntax(),\n\t\t\t\tnew GitHubCodeBlockSyntax(),\n\t\t\t\tnew BlockquoteSyntax(),\n\t\t\t\tnew HorizontalRuleSyntax(),\n\t\t\t\tnew UnorderedListSyntax(),\n\t\t\t\tnew OrderedListSyntax(),\n\t\t\t\tnew TableSyntax(),\n\t\t\t\tnew ParagraphSyntax()\n\t\t\t];\n\t\t}\n\t\treturn syntaxes;\n\t}\n\n\t/**\n\t\tGets whether or not [parser]'s current line should end the \n\t\tprevious block.\n\t**/\n\tpublic static function isAtBlockEnd(parser:BlockParser):Bool\n\t{\n\t\tif (parser.isDone) return true;\n\t\tfor (syntax in syntaxes)\n\t\t{\n\t\t\tif (syntax.canParse(parser) && syntax.canEndBlock) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic function new() {}\n\n\t/**\n\t\tGets the regex used to identify the beginning of this block, if any.\n\t**/\n\tpublic var pattern(get, never):EReg;\n\tfunction get_pattern():EReg\n\t{\n\t\treturn null;\n\t}\n\n\tpublic var canEndBlock(get, never):Bool;\n\tfunction get_canEndBlock():Bool\n\t{\n\t\treturn true;\n\t}\n\n\tpublic function canParse(parser:BlockParser):Bool\n\t{\n\t\treturn pattern.match(parser.current);\n\t}\n\n\tpublic function parse(parser:BlockParser):Node\n\t{\n\t\treturn null;\n\t}\n\n\tpublic function parseChildLines(parser:BlockParser):Array<String>\n\t{\n\t\tvar childLines = [];\n\n\t\twhile (!parser.isDone)\n\t\t{\n\t\t\tif (!pattern.match(parser.current)) break;\n\t\t\tchildLines.push(pattern.matched(1));\n\t\t\tparser.advance();\n\t\t}\n\n\t\treturn childLines;\n\t}\n}\n\nclass EmptyBlockSyntax extends BlockSyntax\n{\n\tpublic function new() { super(); }\n\n\toverride function get_pattern():EReg\n\t{\n\t\treturn BlockSyntax.RE_EMPTY;\n\t}\n\n\toverride public function parse(parser:BlockParser)\n\t{\n\t\tparser.advance();\n\t\t// Don't actually emit anything.\n\t\treturn null;\n\t}\n}\n\n/**\n\tParses setext-style headers.\n**/\nclass SetextHeaderSyntax extends BlockSyntax\n{\n\tpublic function new() { super(); }\n\n\toverride public function canParse(parser:BlockParser)\n\t{\n\t\t// Note: matches *next* line, not the current one. We're looking for the\n\t\t\t// underlining after this line.\n\t\t\treturn parser.matchesNext(BlockSyntax.RE_SETEXT);\n\t}\n\n\toverride public function parse(parser:BlockParser)\n\t{\n\t\tvar re = BlockSyntax.RE_SETEXT;\n\t\tre.match(parser.next);\n\n\t\tvar tag = (re.matched(1).charAt(0) == '=') ? 'h1' : 'h2';\n\t\tvar contents = parser.document.parseInline(parser.current);\n\t\tparser.advance();\n\t\tparser.advance();\n\t\treturn new ElementNode(tag, contents);\n\t}\n}\n\n/**\n\tParses atx-style headers: `## Header ##`.\n**/\nclass HeaderSyntax extends BlockSyntax\n{\n\tpublic function new() { super(); }\n\n\toverride function get_pattern():EReg\n\t{\n\t\treturn BlockSyntax.RE_HEADER;\n\t}\n\n\toverride public function parse(parser:BlockParser)\n\t{\n\t\tpattern.match(parser.current);\n\t\tparser.advance();\n\t\tvar level = pattern.matched(1).length;\n\t\tvar contents = parser.document.parseInline(pattern.matched(2).trim());\n\t\treturn new ElementNode('h$level', contents);\n\t}\n}\n\n\n// Parses email-style blockquotes: `> quote`.\nclass BlockquoteSyntax extends BlockSyntax\n{\n\toverride function get_pattern():EReg\n\t{\n\t\treturn BlockSyntax.RE_BLOCKQUOTE;\n\t}\n\n\toverride public function parseChildLines(parser:BlockParser):Array<String>\n\t{\n\t\tvar childLines = [];\n\n\t\twhile (!parser.isDone)\n\t\t{\n\t\t\tif (pattern.match(parser.current))\n\t\t\t{\n\t\t\t\tchildLines.push(pattern.matched(1));\n\t\t\t\tparser.advance();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// If there's a blockquote, then a newline, then a blockquote, keep the\n\t\t\t\t// blockquotes together.\n\t\t\t\tvar nextMatch = parser.next != null ? pattern.match(parser.next) : false;\n\n\t\t\t\tif (parser.current.trim() == '' && nextMatch)\n\t\t\t\t{\n\t\t\t\t\tchildLines.push('');\n\t\t\t\t\tchildLines.push(pattern.matched(1));\n\t\t\t\t\tparser.advance();\n\t\t\t\t\tparser.advance();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn childLines;\n\t}\n\n\toverride public function parse(parser:BlockParser):Node\n\t{\n\t\tvar childLines = parseChildLines(parser);\n\n\t\t// Recursively parse the contents of the blockquote.\n\t\tvar children = parser.document.parseLines(childLines);\n\n\t\treturn new ElementNode('blockquote', children);\n\t}\n}\n\n// Parses preformatted code blocks that are indented four spaces.\nclass CodeBlockSyntax extends BlockSyntax\n{\n\toverride function get_pattern():EReg\n\t{\n\t\treturn BlockSyntax.RE_INDENT;\n\t}\n\n\toverride public function parseChildLines(parser:BlockParser):Array<String>\n\t{\n\t\tvar childLines = [];\n\n\t\twhile (!parser.isDone)\n\t\t{\n\t\t\tif (pattern.match(parser.current))\n\t\t\t{\n\t\t\t\tchildLines.push(pattern.matched(1));\n\t\t\t\tparser.advance();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// If there's a codeblock, then a newline, then a codeblock, keep the\n\t\t\t\t// code blocks together.\n\t\t\t\tvar nextMatch = parser.next != null ? pattern.match(parser.next) : false;\n\n\t\t\t\tif (parser.current.trim() == '' && nextMatch)\n\t\t\t\t{\n\t\t\t\t\tchildLines.push('');\n\t\t\t\t\tchildLines.push(pattern.matched(1));\n\t\t\t\t\tparser.advance();\n\t\t\t\t\tparser.advance();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn childLines;\n\t}\n\n\toverride public function parse(parser:BlockParser):Node\n\t{\n\t\tvar childLines = parseChildLines(parser);\n\n\t\t// The Markdown tests expect a trailing newline.\n\t\tchildLines.push('');\n\n\t\t// Escape the code.\n\t\tvar escaped = childLines.join('\\n').htmlEscape();\n\n\t\treturn new ElementNode('pre', [ElementNode.text('code', escaped)]);\n\t}\n}\n\n// Parses preformatted code blocks between two ``` sequences.\nclass GitHubCodeBlockSyntax extends BlockSyntax\n{\n\toverride function get_pattern():EReg\n\t{\n\t\treturn BlockSyntax.RE_CODE;\n\t}\n\n\toverride public function parseChildLines(parser:BlockParser):Array<String>\n\t{\n\t\tvar childLines = [];\n\t\tparser.advance();\n\t\t\n\t\twhile (!parser.isDone)\n\t\t{\n\t\t\tif (!pattern.match(parser.current)) {\n\t\t\t\tchildLines.push(parser.current);\n\t\t\t\tparser.advance();\n\t\t\t} else {\n\t\t\t\tparser.advance();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn childLines;\n\t}\n\n\toverride public function parse(parser:BlockParser):Node\n\t{\n\t\t// Get the syntax identifier, if there is one.\n\t\t// pattern.match(parser.current);\n\t\tvar syntax = pattern.matched(1);\n\t\tvar childLines = parseChildLines(parser);\n\t\t\n\t\tvar code = ElementNode.text('code', childLines.join('\\n').htmlEscape());\n\t\tif (syntax != null && syntax.length > 0) {\n\t\t\tcode.attributes.set('class', 'prettyprint '+syntax);\n\t\t}\n\t\treturn new ElementNode('pre', [code]);\n\t}\n}\n\n// Parses horizontal rules like `---`, `_ _ _`, `*\t*\t*`, etc.\nclass HorizontalRuleSyntax extends BlockSyntax\n{\n\toverride function get_pattern():EReg\n\t{\n\t\treturn BlockSyntax.RE_HR;\n\t}\n\n\toverride public function parse(parser:BlockParser):Node\n\t{\n\t\tparser.advance();\n\t\treturn ElementNode.empty('hr');\n\t}\n}\n\n// Parses inline HTML at the block level. This differs from other markdown\n// implementations in several ways:\n//\n// 1.\tThis one is way way WAY simpler.\n// 2.\tAll HTML tags at the block level will be treated as blocks. If you\n//\t\t start a paragraph with `<em>`, it will not wrap it in a `<p>` for you.\n//\t\t As soon as it sees something like HTML, it stops mucking with it until\n//\t\t it hits the next block.\n// 3.\tAbsolutely no HTML parsing or validation is done. We're a markdown\n//\t\t parser not an HTML parser!\nclass BlockHtmlSyntax extends BlockSyntax\n{\n\toverride function get_pattern():EReg\n\t{\n\t\treturn BlockSyntax.RE_HTML;\n\t}\n\n\toverride function get_canEndBlock() return false;\n\n\toverride public function parse(parser:BlockParser):Node\n\t{\n\t\tvar childLines = [];\n\n\t\t// Eat until we hit a blank line.\n\t\twhile (!parser.isDone && !parser.matches(BlockSyntax.RE_EMPTY))\n\t\t{\n\t\t\tchildLines.push(parser.current);\n\t\t\tparser.advance();\n\t\t}\n\n\t\treturn new TextNode(childLines.join('\\n'));\n\t}\n}\n\nclass ListItem\n{\n\tpublic var forceBlock:Bool = false;\n\tpublic var lines(default, null):Array<String>;\n\n\tpublic function new(lines:Array<String>)\n\t{\n\t\tthis.lines = lines;\n\t}\n}\n\n// Parses paragraphs of regular text.\nclass ParagraphSyntax extends BlockSyntax\n{\n\toverride function get_canEndBlock() return false;\n\n\toverride public function canParse(parser:BlockParser):Bool\n\t{\n\t\treturn true;\n\t}\n\n\toverride public function parse(parser:BlockParser):Node\n\t{\n\t\tvar childLines = [];\n\n\t\t// Eat until we hit something that ends a paragraph.\n\t\twhile (!BlockSyntax.isAtBlockEnd(parser))\n\t\t{\n\t\t\tchildLines.push(StringTools.ltrim(parser.current));\n\t\t\tparser.advance();\n\t\t}\n\n\t\tvar contents = parser.document.parseInline(childLines.join('\\n'));\n\t\treturn new ElementNode('p', contents);\n\t}\n}\n\n// Base class for both ordered and unordered lists.\nclass ListSyntax extends BlockSyntax\n{\n\toverride function get_canEndBlock()\n\t{\n\t\treturn false;\n\t}\n\n\tpublic var listTag(default, null):String;\n\n\tpublic function new(listTag:String)\n\t{\n\t\tsuper();\n\t\tthis.listTag = listTag;\n\t}\n\n\toverride public function parse(parser:BlockParser):Node\n\t{\n\t\tvar items = [];\n\t\tvar childLines = [];\n\n\t\tfunction endItem()\n\t\t{\n\t\t\tif (childLines.length > 0)\n\t\t\t{\n\t\t\t\titems.push(new ListItem(childLines));\n\t\t\t\tchildLines = [];\n\t\t\t}\n\t\t}\n\n\t\tvar match:EReg;\n\t\tfunction tryMatch(pattern:EReg) {\n\t\t\tmatch = pattern;\n\t\t\treturn pattern.match(parser.current);\n\t\t}\n\n\t\twhile (!parser.isDone)\n\t\t{\n\t\t\tif (tryMatch(BlockSyntax.RE_EMPTY))\n\t\t\t{\n\t\t\t\t// Add a blank line to the current list item.\n\t\t\t\tchildLines.push('');\n\t\t\t}\n\t\t\telse if (tryMatch(BlockSyntax.RE_UL) || tryMatch(BlockSyntax.RE_OL))\n\t\t\t{\n\t\t\t\t// End the current list item and start a new one.\n\t\t\t\tendItem();\n\t\t\t\tchildLines.push(match.matched(1));\n\t\t\t}\n\t\t\telse if (tryMatch(BlockSyntax.RE_INDENT))\n\t\t\t{\n\t\t\t\t// Strip off indent and add to current item.\n\t\t\t\tchildLines.push(match.matched(1));\n\t\t\t}\n\t\t\telse if (BlockSyntax.isAtBlockEnd(parser))\n\t\t\t{\n\t\t\t\t// Done with the list.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Anything else is paragraph text or other stuff that can be in a list\n\t\t\t\t// item. However, if the previous item is a blank line, this means we're\n\t\t\t\t// done with the list and are starting a new top-level paragraph.\n\t\t\t\tif ((childLines.length > 0) && (childLines[childLines.length-1] == '')) break;\n\t\t\t\tchildLines.push(parser.current);\n\t\t\t}\n\t\t\tparser.advance();\n\t\t}\n\n\t\tendItem();\n\n\t\t// Markdown, because it hates us, specifies two kinds of list items. If you\n\t\t// have a list like:\n\t\t//\n\t\t// * one\n\t\t// * two\n\t\t//\n\t\t// Then it will insert the conents of the lines directly in the <li>, like:\n\t\t// <ul>\n\t\t//\t <li>one</li>\n\t\t//\t <li>two</li>\n\t\t// <ul>\n\t\t//\n\t\t// If, however, there are blank lines between the items, each is wrapped in\n\t\t// paragraphs:\n\t\t//\n\t\t// * one\n\t\t//\n\t\t// * two\n\t\t//\n\t\t// <ul>\n\t\t//\t <li><p>one</p></li>\n\t\t//\t <li><p>two</p></li>\n\t\t// <ul>\n\t\t//\n\t\t// In other words, sometimes we parse the contents of a list item like a\n\t\t// block, and sometimes line an inline. The rules our parser implements are:\n\t\t//\n\t\t// - If it has more than one line, it's a block.\n\t\t// - If the line matches any block parser (BLOCKQUOTE, HEADER, HR, INDENT,\n\t\t//\t UL, OL) it's a block. (This is for cases like \"* > quote\".)\n\t\t// - If there was a blank line between this item and the previous one, it's\n\t\t//\t a block.\n\t\t// - If there was a blank line between this item and the next one, it's a\n\t\t//\t block.\n\t\t// - Otherwise, parse it as an inline.\n\n\t\t// Remove any trailing empty lines and note which items are separated by\n\t\t// empty lines. Do this before seeing which items are single-line so that\n\t\t// trailing empty lines on the last item don't force it into being a block.\n\t\tfor (i in 0...items.length)\n\t\t{\n\t\t\tvar len = items[i].lines.length;\n\t\t\tfor (jj in 1...len+1)\n\t\t\t{\n\t\t\t\tvar j = len - jj;\n\t\t\t\tif (BlockSyntax.RE_EMPTY.match(items[i].lines[j]))\n\t\t\t\t{\n\t\t\t\t\t// Found an empty line. Item and one after it are blocks.\n\t\t\t\t\tif (i < items.length - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\titems[i].forceBlock = true;\n\t\t\t\t\t\titems[i + 1].forceBlock = true;\n\t\t\t\t\t}\n\t\t\t\t\titems[i].lines.pop();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Convert the list items to Nodes.\n\t\tvar itemNodes:Array<Node> = [];\n\t\tfor (item in items)\n\t\t{\n\t\t\tvar blockItem = item.forceBlock || (item.lines.length > 1);\n\n\t\t\t// See if it matches some block parser.\n\t\t\tvar blocksInList = [\n\t\t\t\tBlockSyntax.RE_BLOCKQUOTE,\n\t\t\t\tBlockSyntax.RE_HEADER,\n\t\t\t\tBlockSyntax.RE_HR,\n\t\t\t\tBlockSyntax.RE_INDENT,\n\t\t\t\tBlockSyntax.RE_UL,\n\t\t\t\tBlockSyntax.RE_OL\n\t\t\t];\n\n\t\t\tif (!blockItem)\n\t\t\t{\n\t\t\t\tfor (pattern in blocksInList)\n\t\t\t\t{\n\t\t\t\t\tif (pattern.match(item.lines[0]))\n\t\t\t\t\t{\n\t\t\t\t\t\tblockItem = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Parse the item as a block or inline.\n\t\t\tif (blockItem)\n\t\t\t{\n\t\t\t\t// Block list item.\n\t\t\t\tvar children = parser.document.parseLines(item.lines);\n\n\t\t\t\t// if we have a single p child we might have been forced into block\n\t\t\t\t// mode by line breaks. if not forceBlock (empty line before/after)\n\t\t\t\t// we can use text of p as li child <li><p>foo</p></li> -> <li>foo</li>\n\t\t\t\tif (!item.forceBlock && children.length == 1)\n\t\t\t\t{\n\t\t\t\t\tif (Std.is(children[0], ElementNode))\n\t\t\t\t\t{\n\t\t\t\t\t\tvar node:ElementNode = cast children[0];\n\t\t\t\t\t\tif (node.tag == 'p') children = node.children;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\titemNodes.push(new ElementNode('li', children));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Raw list item.\n\t\t\t\tvar contents = parser.document.parseInline(item.lines[0]);\n\t\t\t\titemNodes.push(new ElementNode('li', contents));\n\t\t\t}\n\t\t}\n\n\t\treturn new ElementNode(listTag, itemNodes);\n\t}\n}\n\n// Parses unordered lists.\nclass UnorderedListSyntax extends ListSyntax\n{\n\toverride function get_pattern():EReg\n\t{\n\t\treturn BlockSyntax.RE_UL;\n\t}\n\n\tpublic function new()\n\t{\n\t\tsuper('ul');\n\t}\n}\n\n// Parses ordered lists.\nclass OrderedListSyntax extends ListSyntax\n{\n\toverride function get_pattern():EReg\n\t{\n\t\treturn BlockSyntax.RE_OL;\n\t}\n\n\tpublic function new()\n\t{\n\t\tsuper('ol');\n\t}\n}\n\nclass TableSyntax extends BlockSyntax\n{\n\tstatic var TABLE_PATTERN = new EReg('^(.+? +:?\\\\|:? +)+(.+)$', '');\n\tstatic var CELL_PATTERN = new EReg('(\\\\|)?([^\\\\|]+)(\\\\|)?', 'g');\n\n\tpublic function new()\n\t{\n\t\tsuper();\n\t}\n\n\toverride function get_pattern():EReg\n\t{\n\t\treturn TABLE_PATTERN;\n\t}\n\n\toverride function get_canEndBlock()\n\t{\n\t\treturn false;\n\t}\n  \n\toverride public function parse(parser:BlockParser):Node\n\t{\n\t\tvar lines = [];\n\n\t\twhile (!parser.isDone && parser.matches(TABLE_PATTERN))\n\t\t{\n\t\t\tlines.push(parser.current);\n\t\t\tparser.advance();\n\t\t}\n\t\t\n\t\tvar heads:Array<Node> = [];\n\t\tvar rows:Array<Node> = [];\n\t\tvar align = [];\n\n\t\tvar headLine = lines.shift();\n\t\tvar alignLine = lines.shift();\n\n\t\t// get alignment from separator line\n\t\tvar aligns = [];\n\t\tif (alignLine != null) {\n\t\t\tCELL_PATTERN.map(alignLine, function(e){\n\t\t\t\tvar text = e.matched(2);\n\t\t\t\tvar align = text.charAt(0) == ':' \n\t\t\t\t\t? text.charAt(text.length - 1) == ':' ? 'center' : 'left'\n\t\t\t\t\t: text.charAt(text.length - 1) == ':' ? 'right' : 'left';\n\t\t\t\taligns.push(align);\n\t\t\t\treturn '';\n\t\t\t});\n\t\t}\n\t\t\n\t\t// create thead\n\t\tvar index = 0;\n\t\tCELL_PATTERN.map(headLine, function(e){\n\t\t\tvar text = StringTools.trim(e.matched(2));\n\t\t\tvar cell = new ElementNode('th', parser.document.parseInline(text));\n\t\t\tif (aligns[index] != 'left') cell.attributes.set('align', aligns[index]);\n\t\t\theads.push(cell);\n\t\t\tindex += 1;\n\t\t\treturn '';\n\t\t});\n\n\t\tfor (line in lines)\n\t\t{\n\t\t\tvar cols:Array<Node> = [];\n\t\t\trows.push(new ElementNode('tr', cols));\n\n\t\t\tvar index = 0;\n\t\t\tCELL_PATTERN.map(line, function(e){\n\t\t\t\tvar text = StringTools.trim(e.matched(2));\n\t\t\t\tvar cell = new ElementNode('td', parser.document.parseInline(text));\n\t\t\t\tif (aligns[index] != 'left') cell.attributes.set('align', aligns[index]);\n\t\t\t\tcols.push(cell);\n\t\t\t\tindex += 1;\n\t\t\t\treturn '';\n\t\t\t});\n\t\t}\n\n\t\treturn new ElementNode('table', [\n\t\t\tnew ElementNode('thead', heads), \n\t\t\tnew ElementNode('tbody', rows)\n\t\t]);\n\t}\n}\n","package markdown;\n\nimport markdown.AST;\n\n/**\n\tTranslates a parsed AST to HTML.\n**/\nclass HtmlRenderer implements NodeVisitor\n{\n\tstatic var BLOCK_TAGS = new EReg('blockquote|h1|h2|h3|h4|h5|h6|hr|p|pre', '');\n\n\tvar buffer:StringBuf;\n\n\tpublic function new() {}\n\n\tpublic function render(nodes:Array<Node>):String\n\t{\n\t\tbuffer = new StringBuf();\n\t\tfor (node in nodes) node.accept(this);\n\t\treturn buffer.toString();\n\t}\n\n\tpublic function visitText(text:TextNode):Void\n\t{\n\t\tbuffer.add(text.text);\n\t}\n\n\tpublic function visitElementBefore(element:ElementNode):Bool\n\t{\n\t\t// Hackish. Separate block-level elements with newlines.\n\t\tif (buffer.toString() != \"\" && BLOCK_TAGS.match(element.tag))\n\t\t{\n\t\t\tbuffer.add('\\n');\n\t\t}\n\n\t\tbuffer.add('<${element.tag}');\n\n\t\t// Sort the keys so that we generate stable output.\n\t\t// TODO(rnystrom): This assumes keys returns a fresh mutable\n\t\t// collection.\n\t\tvar attributeNames = [for (k in element.attributes.keys()) k];\n\t\tattributeNames.sort(sortAttributes);\n\t\tfor (name in attributeNames)\n\t\t{\n\t\t\tbuffer.add(' $name=\"${element.attributes.get(name)}\"');\n\t\t}\n\n\t\tif (element.isEmpty())\n\t\t{\n\t\t\t// Empty element like <hr/>.\n\t\t\tbuffer.add(' />');\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbuffer.add('>');\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tpublic function visitElementAfter(element:ElementNode):Void\n\t{\n\t\tbuffer.add('</${element.tag}>');\n\t}\n\n\tstatic var attributeOrder = ['src', 'alt'];\n\n\tstatic function sortAttributes(a:String, b:String)\n\t{\n\t\tvar ia = attributeOrder.indexOf(a);\n\t\tvar ib = attributeOrder.indexOf(a);\n\t\tif (ia > -1 && ib > -1) return ia - ib;\n\t\treturn Reflect.compare(a, b);\n\t}\n}\n","package markdown;\n\nimport markdown.AST;\nimport Markdown;\nusing StringTools;\nusing Lambda;\n\n/**\n\tMaintains the internal state needed to parse inline span elements in\n\tmarkdown.\n**/\nclass InlineParser\n{\n\tstatic var defaultSyntaxes = [\n\t\t// This first regexp matches plain text to accelerate parsing.\tIt must\n\t\t// be written so that it does not match any prefix of any following\n\t\t// syntax.\tMost markdown is plain text, so it is faster to match one\n\t\t// regexp per 'word' rather than fail to match all the following regexps\n\t\t// at each non-syntax character position.\tIt is much more important\n\t\t// that the regexp is fast than complete (for example, adding grouping\n\t\t// is likely to slow the regexp down enough to negate its benefit).\n\t\t// Since it is purely for optimization, it can be removed for debugging.\n\n\t\t// TODO(amouravski): this regex will glom up any custom syntaxes unless\n\t\t// they're at the beginning.\n\t\tnew AutolinkSyntaxWithoutBrackets(),\n\t\tnew TextSyntax(' {2,}\\n', '<br />\\n'),\n\t\tnew TextSyntax('\\\\s*[A-Za-z0-9]+'),\n\n\t\t// The real syntaxes.\n\n\t\tnew AutolinkSyntax(),\n\t\tnew LinkSyntax(),\n\t\tnew ImgSyntax(),\n\n\t\t// \"*\" surrounded by spaces is left alone.\n\t\tnew TextSyntax(' \\\\* '),\n\t\t// \"_\" surrounded by spaces is left alone.\n\t\tnew TextSyntax(' _ '),\n\t\t// Leave already-encoded HTML entities alone. Ensures we don't turn\n\t\t// \"&amp;\" into \"&amp;amp;\"\n\t\tnew TextSyntax('&[#a-zA-Z0-9]*;'),\n\t\t// Encode \"&\".\n\t\tnew TextSyntax('&', '&amp;'),\n\t\t// Leave HTML as is.\n\t\tnew TextSyntax('</?\\\\w+.*?>'),\n\t\t// Encode \"<\". (Why not encode \">\" too? Gruber is toying with us.)\n\t\tnew TextSyntax('<', '&lt;'),\n\t\t// Parse \"**strong**\" tags.\n\t\tnew TagSyntax('\\\\*\\\\*', 'strong'),\n\t\t// Parse \"__strong__\" tags.\n\t\tnew TagSyntax('__', 'strong'),\n\t\t// Parse \"*emphasis*\" tags.\n\t\tnew TagSyntax('\\\\*', 'em'),\n\t\t// Parse \"_emphasis_\" tags.\n\t\tnew TagSyntax('\\\\b_', 'em', '_\\\\b'),\n\t\t// Parse inline code within double backticks: \"``code``\".\n\t\tnew CodeSyntax('``\\\\s?((?:.|\\\\n)*?)\\\\s?``'),\n\t\t// Parse inline code within backticks: \"`code`\".\n\t\tnew CodeSyntax('`([^`]*)`')\n\t\t// We will add the LinkSyntax once we know about the specific link resolver.\n\t];\n\n\t// The string of markdown being parsed.\n\tpublic var source(default, null):String;\n\n\t// The markdown document this parser is parsing.\n\tpublic var document(default, null):Document;\n\n\tpublic var syntaxes(default, null):Array<InlineSyntax>;\n\n\t// The current read position.\n\tpublic var pos(default, null):Int = 0;\n\n\t// Starting position of the last unconsumed text.\n\tpublic var start:Int = 0;\n\n\tpublic var stack(default, null):Array<TagState>;\n\n\tpublic function new(source:String, document:Document)\n\t{\n\t\tthis.source = source;\n\t\tthis.document = document;\n\t\tstack = [];\n\n\t\t// User specified syntaxes will be the first syntaxes to be evaluated.\n\t\tif (document.inlineSyntaxes != null)\n\t\t{\n\t\t\tsyntaxes = [];\n\t\t\tfor (syntax in document.inlineSyntaxes)\n\t\t\t\tsyntaxes.push(syntax);\n\t\t\tfor (syntax in defaultSyntaxes)\n\t\t\t\tsyntaxes.push(syntax);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsyntaxes = defaultSyntaxes;\n\t\t}\n\n\t\t// Custom link resolver goes after the generic text syntax.\n\t\tsyntaxes.insert(1, new LinkSyntax(document.linkResolver));\n\t}\n\t\n\tpublic function parse():Array<Node>\n\t{\n\t\t// Make a fake top tag to hold the results.\n\t\tstack.push(new TagState(0, 0, null));\n\n\t\twhile (!isDone)\n\t\t{\n\t\t\tvar matched = false;\n\n\t\t\t// See if any of the current tags on the stack match. We don't allow tags\n\t\t\t// of the same kind to nest, so this takes priority over other possible // matches.\n\t\t\tfor (i in 1...stack.length)\n\t\t\t{\n\t\t\t\tif (stack[stack.length - i].tryMatch(this))\n\t\t\t\t{\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (matched) continue;\n\n\t\t\t// See if the current text matches any defined markdown syntax.\n\t\t\tfor (syntax in syntaxes)\n\t\t\t{\n\t\t\t\tif (syntax.tryMatch(this))\n\t\t\t\t{\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (matched) continue;\n\n\t\t\t// If we got here, it's just text.\n\t\t\tadvanceBy(1);\n\t\t}\n\n\t\t// Unwind any unmatched tags and get the results.\n\t\treturn stack[0].close(this);\n\t}\n\n\tpublic function writeText()\n\t{\n\t\twriteTextRange(start, pos);\n\t\tstart = pos;\n\t}\n\n\tpublic function writeTextRange(start:Int, end:Int)\n\t{\n\t\tif (end > start)\n\t\t{\n\t\t\tvar text = source.substring(start, end);\n\t\t\tvar nodes = stack[stack.length - 1].children;\n\n\t\t\t// If the previous node is text too, just append.\n\t\t\tif ((nodes.length > 0) && (Std.is(nodes[nodes.length - 1], TextNode)))\n\t\t\t{\n\t\t\t\tvar lastNode:TextNode = cast nodes[nodes.length - 1];\n\t\t\t\tvar newNode = createText('${lastNode.text}$text');\n\t\t\t\tnodes[nodes.length - 1] = newNode;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnodes.push(createText(text));\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic function createText(text:String)\n\t{\n\t\treturn new TextNode(unescape(text));\n\t}\n\n\tpublic function addNode(node:Node)\n\t{\n\t\tstack[stack.length - 1].children.push(node);\n\t}\n\n\t// TODO(rnystrom): Only need this because RegExp doesn't let you start\n\t// searching from a given offset.\n\tpublic var currentSource(get, never):String;\n\tfunction get_currentSource() return source.substring(pos, source.length);\n\n\tpublic var isDone(get, never):Bool;\n\tfunction get_isDone() return pos == source.length;\n\n\tpublic function advanceBy(length:Int)\n\t{\n\t\tpos += length;\n\t}\n\n\tpublic function consume(length:Int)\n\t{\n\t\tpos += length;\n\t\tstart = pos;\n\t}\n\n\tpublic function unescape(text:String):String\n\t{\n  \t\ttext = ~/\\\\([\\\\`*_{}[\\]()#+-.!])/g.replace(text, '$1');\n\t\ttext = StringTools.replace(text, '\\t', '    ');\n\t\treturn text;\n\t}\n}\n\n/**\n\tRepresents one kind of markdown tag that can be parsed.\n**/\nclass InlineSyntax\n{\n\tvar pattern:EReg;\n\n\tpublic function new(pattern:String)\n\t{\n\t\tthis.pattern = new EReg(pattern, 'm');\n\t}\n\n\tpublic function tryMatch(parser:InlineParser):Bool\n\t{\n\t\tif (pattern.match(parser.currentSource) && (pattern.matchedPos().pos == 0))\n\t\t{\n\t\t\t// Write any existing plain text up to this point.\n\t\t\tparser.writeText();\n\n\t\t\tif (onMatch(parser))\n\t\t\t{\n\t\t\t\tparser.consume(pattern.matched(0).length);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction onMatch(parser:InlineParser):Bool\n\t{\n\t\treturn false;\n\t}\n}\n\n/**\n\tMatches stuff that should just be passed through as straight text.\n**/\nclass TextSyntax extends InlineSyntax\n{\n\tvar substitute:String;\n\n\tpublic function new(pattern:String, ?substitute:String)\n\t{\n\t\tsuper(pattern);\n\t\tthis.substitute = substitute;\n\t}\n\n\toverride function onMatch(parser:InlineParser):Bool\n\t{\n\t\tif (substitute == null)\n\t\t{\n\t\t\t// Just use the original matched text.\n\t\t\tparser.advanceBy(pattern.matched(0).length);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Insert the substitution.\n\t\tparser.addNode(parser.createText(substitute));\n\t\treturn true;\n\t}\n}\n\n/**\n\tMatches autolinks like `<http://foo.com>`.\n**/\nclass AutolinkSyntax extends InlineSyntax\n{\n\tpublic function new()\n\t{\n\t\t// TODO(rnystrom): Make case insensitive.\n\t\tsuper('<((http|https|ftp)://[^>]*)>');\n\t}\n\n\toverride function onMatch(parser:InlineParser):Bool\n\t{\n\t\tvar url = pattern.matched(1);\n\n\t\tvar anchor = ElementNode.text('a', url.htmlEscape());\n\t\tanchor.attributes.set('href', url);\n\t\tparser.addNode(anchor);\n\n\t\treturn true;\n\t}\n}\n\n/**\n\tMatches autolinks like `http://foo.com`.\n**/\nclass AutolinkSyntaxWithoutBrackets extends InlineSyntax\n{\n\tpublic function new()\n\t{\n\t\t// TODO(rnystrom): Make case insensitive.\n\t\tsuper('\\\\b((http|https|ftp)://[^\\\\s]*)\\\\b');\n\t}\n\n\toverride function tryMatch(parser) {\n\t\treturn super.tryMatch(parser);\n\t}\n\n\toverride function onMatch(parser:InlineParser):Bool\n\t{\n\t\tvar url = pattern.matched(1);\n\n\t\tvar anchor = ElementNode.text('a', url.htmlEscape());\n\t\tanchor.attributes.set('href', url);\n\t\tparser.addNode(anchor);\n\n\t\treturn true;\n\t}\n}\n\n/**\n\tMatches syntax that has a pair of tags and becomes an element, like `*` for\n\t`<em>`. Allows nested tags.\n**/\nclass TagSyntax extends InlineSyntax\n{\n\tpublic var endPattern(default, null):EReg;\n\tpublic var tag(default, null):String;\n\n\tpublic function new(pattern:String, ?tag:String, ?end:String)\n\t{\n\t\tsuper(pattern);\n\t\tthis.tag = tag;\n\t\tthis.endPattern = new EReg((end == null) ? pattern : end, 'm');\n\t}\n\t\n\toverride function onMatch(parser:InlineParser):Bool\n\t{\n\t\tparser.stack.push(new TagState(parser.pos, \n\t\t\tparser.pos + pattern.matched(0).length, this));\n\t\treturn true;\n\t}\n\n\tpublic function onMatchEnd(parser:InlineParser, state:TagState):Bool\n\t{\n\t\tparser.addNode(new ElementNode(tag, state.children));\n\t\treturn true;\n\t}\n}\n\n/**\n\tMatches inline links like `[blah] [id]` and `[blah] (url)`.\n**/\nclass LinkSyntax extends TagSyntax\n{\n\tvar linkResolver:Resolver;\n\n\t// The regex for the end of a link needs to handle both reference style and\n\t// inline styles as well as optional titles for inline links. To make that\n\t// a bit more palatable, this breaks it into pieces.\n\tstatic var linkPattern = '\\\\](?:('+\n\t\t'\\\\s?\\\\[([^\\\\]]*)\\\\]'+\n\t\t'|'+\n\t\t'\\\\s?\\\\(([^ )]+)(?:[ ]*\"([^\"]+)\"|)\\\\)'+\n\t\t')|)';\n\n\t// The groups matched by this are:\n\t// 1: Will be non-empty if it's either a ref or inline link. Will be empty\n\t//    if it's just a bare pair of square brackets with nothing after them.\n\t// 2: Contains the id inside [] for a reference-style link.\n\t// 3: Contains the URL for an inline link.\n\t// 4: Contains the title, if present, for an inline link.\n\tpublic function new(?linkResolver:Resolver)\n\t{\n\t\tsuper('\\\\[', null, linkPattern);\n\t\tthis.linkResolver = linkResolver;\n\t}\n\n\toverride function onMatchEnd(parser:InlineParser, state:TagState):Bool\n\t{\n\t\tvar url:String;\n\t\tvar title:String;\n\n\t\t// If we didn't match refLink or inlineLink, then it means there was\n\t\t// nothing after the first square bracket, so it isn't a normal markdown\n\t\t// link at all. Instead, we allow users of the library to specify a special\n\t\t// resolver function ([linkResolver]) that may choose to handle\n\t\t// this. Otherwise, it's just treated as plain text.\n\t\tif ((endPattern.matched(1) == null) || (endPattern.matched(1) == ''))\n\t\t{\n\t\t\tif (linkResolver == null) return false;\n\n\t\t\t// Only allow implicit links if the content is just text.\n\t\t\t// TODO(rnystrom): Do we want to relax this?\n\t\t\tif (state.children.length != 1) return false;\n\t\t\tif (!Std.is(state.children[0], TextNode)) return false;\n\n\t\t\tvar link:TextNode = cast state.children[0];\n\n\t\t\t// See if we have a resolver that will generate a link for us.\n\t\t\tvar node = linkResolver(link.text);\n\t\t\tif (node == null) return false;\n\n\t\t\tparser.addNode(node);\n\t\t\treturn true;\n\t\t}\n\n\t\tif ((endPattern.matched(3) != null) && (endPattern.matched(3) != '')) {\n\t\t\t// Inline link like [foo](url).\n\t\t\turl = endPattern.matched(3);\n\t\t\ttitle = endPattern.matched(4);\n\n\t\t\t// For whatever reason, markdown allows angle-bracketed URLs here.\n\t\t\tif (url.startsWith('<') && url.endsWith('>'))\n\t\t\t{\n\t\t\t\turl = url.substring(1, url.length - 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Reference link like [foo] [bar].\n\t\t\tvar id = endPattern.matched(2);\n\t\t\tif (id == '')\n\t\t\t{\n\t\t\t\t// The id is empty (\"[]\") so infer it from the contents.\n\t\t\t\tid = parser.source.substring(state.startPos + 1, parser.pos);\n\t\t\t}\n\n\t\t\t// References are case-insensitive.\n\t\t\tid = id.toLowerCase();\n\n\t\t\t// Look up the link.\n\t\t\tvar link = parser.document.refLinks.get(id);\n\n\t\t\t// If it's an unknown link just emit plaintext.\n\t\t\tif (link == null) return false;\n\n\t\t\turl = link.url;\n\t\t\ttitle = link.title;\n\t\t}\n\n\t\tvar anchor = new ElementNode('a', state.children);\n\t\tanchor.attributes.set('href', url.htmlEscape());\n\t\t\n\t\tif ((title != null) && (title != ''))\n\t\t{\n\t\t\tanchor.attributes.set('title', title.htmlEscape());\n\t\t}\n\n\t\tparser.addNode(anchor);\n\t\treturn true;\n\t}\n}\n\n/**\n\tMatches inline links like `[blah] [id]` and `[blah] (url)`.\n**/\nclass ImgSyntax extends TagSyntax\n{\n\tvar linkResolver:Resolver;\n\n\t// The regex for the end of a link needs to handle both reference style and\n\t// inline styles as well as optional titles for inline links. To make that\n\t// a bit more palatable, this breaks it into pieces.\n\tstatic var linkPattern = '\\\\](?:('+\n\t\t'\\\\s?\\\\[([^\\\\]]*)\\\\]'+\n\t\t'|'+\n\t\t'\\\\s?\\\\(([^ )]+)(?:[ ]*\"([^\"]+)\"|)\\\\)'+\n\t\t')|)';\n\n\t// The groups matched by this are:\n\t// 1: Will be non-empty if it's either a ref or inline link. Will be empty\n\t//    if it's just a bare pair of square brackets with nothing after them.\n\t// 2: Contains the id inside [] for a reference-style link.\n\t// 3: Contains the URL for an inline link.\n\t// 4: Contains the title, if present, for an inline link.\n\tpublic function new(?linkResolver:Resolver)\n\t{\n\t\tsuper('!\\\\[', null, linkPattern);\n\t\tthis.linkResolver = linkResolver;\n\t}\n\n\toverride function onMatchEnd(parser:InlineParser, state:TagState):Bool\n\t{\n\t\tvar url:String;\n\t\tvar title:String;\n\n\t\t// If we didn't match refLink or inlineLink, then it means there was\n\t\t// nothing after the first square bracket, so it isn't a normal markdown\n\t\t// link at all. Instead, we allow users of the library to specify a special\n\t\t// resolver function ([linkResolver]) that may choose to handle\n\t\t// this. Otherwise, it's just treated as plain text.\n\t\tif ((endPattern.matched(1) == null) || (endPattern.matched(1) == ''))\n\t\t{\n\t\t\tif (linkResolver == null) return false;\n\n\t\t\t// Only allow implicit links if the content is just text.\n\t\t\t// TODO(rnystrom): Do we want to relax this?\n\t\t\tif (state.children.length != 1) return false;\n\t\t\tif (!Std.is(state.children[0], TextNode)) return false;\n\n\t\t\tvar link:TextNode = cast state.children[0];\n\n\t\t\t// See if we have a resolver that will generate a link for us.\n\t\t\tvar node = linkResolver(link.text);\n\t\t\tif (node == null) return false;\n\n\t\t\tparser.addNode(node);\n\t\t\treturn true;\n\t\t}\n\n\t\tif ((endPattern.matched(3) != null) && (endPattern.matched(3) != '')) {\n\t\t\t// Inline link like [foo](url).\n\t\t\turl = endPattern.matched(3);\n\t\t\ttitle = endPattern.matched(4);\n\n\t\t\t// For whatever reason, markdown allows angle-bracketed URLs here.\n\t\t\tif (url.startsWith('<') && url.endsWith('>'))\n\t\t\t{\n\t\t\t\turl = url.substring(1, url.length - 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Reference link like [foo] [bar].\n\t\t\tvar id = endPattern.matched(2);\n\t\t\tif (id == '')\n\t\t\t{\n\t\t\t\t// The id is empty (\"[]\") so infer it from the contents.\n\t\t\t\tid = parser.source.substring(state.startPos + 1, parser.pos);\n\t\t\t}\n\n\t\t\t// References are case-insensitive.\n\t\t\tid = id.toLowerCase();\n\n\t\t\t// Look up the link.\n\t\t\tvar link = parser.document.refLinks.get(id);\n\n\t\t\t// If it's an unknown link just emit plaintext.\n\t\t\tif (link == null) return false;\n\n\t\t\turl = link.url;\n\t\t\ttitle = link.title;\n\t\t}\n\n\t\tvar img = new ElementNode('img', null);\n\t\timg.attributes.set('src', url.htmlEscape());\n\t\tif (state.children.length == 1 && Std.is(state.children[0], TextNode))\n\t\t{\n\t\t\tvar alt:TextNode = cast state.children[0];\n\t\t\timg.attributes.set('alt', alt.text);\n\t\t}\n\t\t\n\t\tif ((title != null) && (title != ''))\n\t\t{\n\t\t\timg.attributes.set('title', title.htmlEscape());\n\t\t}\n\n\t\tparser.addNode(img);\n\t\treturn true;\n\t}\n}\n\n// Matches backtick-enclosed inline code blocks.\nclass CodeSyntax extends InlineSyntax\n{\n\tpublic function new(pattern:String)\n\t{\n\t\tsuper(pattern);\n\t}\n\t\n\toverride function onMatch(parser:InlineParser):Bool\n\t{\n\t\tparser.addNode(ElementNode.text('code', pattern.matched(1).htmlEscape()));\n\t\treturn true;\n\t}\n}\n\n// Keeps track of a currently open tag while it is being parsed. The parser\n// maintains a stack of these so it can handle nested tags.\nclass TagState\n{\n\t// The point in the original source where this tag started.\n\tpublic var startPos(default, null):Int;\n\n\t// The point in the original source where open tag ended.\n\tpublic var endPos(default, null):Int;\n\n\t// The syntax that created this node.\n\tpublic var syntax(default, null):TagSyntax;\n\n\t// The children of this node. Will be `null` for text nodes.\n\tpublic var children(default, null):Array<Node>;\n\n\tpublic function new(startPos:Int, endPos:Int, syntax:TagSyntax)\n\t{\n\t\tthis.startPos = startPos;\n\t\tthis.endPos = endPos;\n\t\tthis.syntax = syntax;\n\t\tchildren = [];\n\t}\n\t\n\t// Attempts to close this tag by matching the current text against its end\n\t// pattern.\n\tpublic function tryMatch(parser:InlineParser):Bool\n\t{\n\t\tif (syntax.endPattern.match(parser.currentSource) \n\t\t\t&& (syntax.endPattern.matchedPos().pos == 0))\n\t\t{\n\t\t\t// Close the tag.\n\t\t\tclose(parser);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// Pops this tag off the stack, completes it, and adds it to the output.\n\t// Will discard any unmatched tags that happen to be above it on the stack.\n\t// If this is the last node in the stack, returns its children.\n\tpublic function close(parser:InlineParser):Array<Node>\n\t{\n\t\t// If there are unclosed tags on top of this one when it's closed, that\n\t\t// means they are mismatched. Mismatched tags are treated as plain text in\n\t\t// markdown. So for each tag above this one, we write its start tag as text\n\t\t// and then adds its children to this one's children.\n\t\tvar index = parser.stack.indexOf(this);\n\n\t\t// Remove the unmatched children.\n\t\tvar unmatchedTags = //parser.stack.slice(index + 1);\n\t\t\tparser.stack.splice(index + 1, parser.stack.length-index);\n\n\t\t// Flatten them out onto this tag.\n\t\tfor (unmatched in unmatchedTags)\n\t\t{\n\t\t\t// Write the start tag as text.\n\t\t\tparser.writeTextRange(unmatched.startPos, unmatched.endPos);\n\n\t\t\t// Bequeath its children unto this tag.\n\t\t\tfor (child in unmatched.children)\n\t\t\t\tchildren.push(child);\n\t\t}\n\n\t\t// Pop this off the stack.\n\t\tparser.writeText();\n\t\tparser.stack.pop();\n\n\t\t// If the stack is empty now, this is the special \"results\" node.\n\t\tif (parser.stack.length == 0) return children;\n\n\t\t// We are still parsing, so add this to its parent's children.\n\t\tif (syntax.onMatchEnd(parser, this))\n\t\t{\n\t\t\tparser.consume(syntax.endPattern.matched(0).length);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Didn't close correctly so revert to text.\n\t\t\tparser.start = startPos;\n\t\t\tparser.advanceBy(syntax.endPattern.matched(0).length);\n\t\t}\n\n\t\treturn null;\n\t}\n}\n"],
"names":[],
"mappings":"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"
}